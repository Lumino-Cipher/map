<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG Map Viewer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
        }
        body {
            font-family: "Inter", sans-serif;
            background-color: #1a202c; /* Dark blue background for the area around the map */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center; /* Center content vertically */
            padding: 0; /* Remove padding for full screen */
        }
        .container {
            background-color: #1a202c; /* Match body background */
            border-radius: 0; /* No rounded corners for full screen */
            box-shadow: none; /* No shadow for full screen */
            width: 100vw; /* Full viewport width */
            height: 100vh; /* Full viewport height */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center; /* Center content vertically */
            padding: 0;
        }
        #svg-display-area {
            width: 100%;
            height: 100%;
            /* Sea zone fill is now handled by the ocean.png pattern,
                so this background color is less critical but kept as a fallback */
            background-color: #e0f2f7;
            display: flex; /* Use flex to center SVG if it doesn't fill entirely */
            justify-content: center;
            align-items: center;
        }
        #svg-display-area svg {
            display: block;
            width: 100%;
            height: 100%; /* Make SVG fill its container */
        }
        .error-message {
            color: #ef4444;
            margin-top: 15px;
            font-weight: bold;
            position: absolute; /* Position error message over content */
            top: 20px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px 20px;
            border-radius: 8px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="error-message" class="error-message hidden"></div>
        <div id="svg-display-area">
            </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const svgDisplayArea = document.getElementById('svg-display-area');
            const errorMessageDiv = document.getElementById('error-message');

            let selectedPaths = []; // Stores paths of the currently selected territory
            let originalFills = new Map(); // Maps path elements to their original fill colors (can be hex or url(#patternId))

            // Define pastel colors for territories without flags
            // Adjusted for a darker, more muted theme
            const powerColors = {
                "US": "#152238",     // Desaturated dark blue
                "UK": "#06402B",     // Desaturated dark green
                "USSR": "#8A4A4A",   // Desaturated dark red
                "Germany": "#ae4223",  // Desaturated dark orange
                "Japan": "#6E4A8A",    // Desaturated dark purple
                "Italy": "#006400",    // Desaturated dark teal (distinct from UK green)
                "China": "#8A5E4A",    // Desaturated dark peach/brown
                "Commonwealth": "#c0a409", // Desaturated dark cyan
                "France": "#872543",   // Desaturated dark pink
                "Neutral": "#3A3A3A",  // Darker grey
                "Impassable": "#000000" // Even darker grey
            };


            // Define territories that should display flags
            const flagTerritories = {
                "US": ["Eastern United States", "Central United States", "Western United States", "Alaska", "Aleutian Islands", "Greenland", "Hawaiian Islands", "Line Islands", "Johnston Island", "Wake Island", "Midway", "Guam", "Philippines"],
                "UK": ["United Kingdom", "Scotland", "Iceland"],
                "Germany": ["Western Germany", "Germany", "Greater Southern Germany"],
                "Italy": ["Northern Italy", "Southern Italy", "Sicily", "Sardinia"],
                "Commonwealth": ["South West Africa", "Union of South Africa", "Western Australia", "Northern Territory", "South Australia", "Queensland", "New South Wales", "Victoria", "New Zealand", "Ontario", "Quebec"],
                "France": ["France", "France City of Vichy", "Normandy Bordeaux"],
                "China": [], // Leave unchanged
                "Japan": [], // Leave unchanged
                "USSR": [] // Leave unchanged
            };

            // Function to display error messages
            function showError(message) {
                errorMessageDiv.textContent = message;
                errorMessageDiv.classList.remove('hidden');
            }

            // Function to clear error messages
            function clearError() {
                errorMessageDiv.classList.add('hidden');
                errorMessageDiv.textContent = '';
            }

            // Automatically load map.svg
            fetch('map.svg')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.text();
                })
                .then(svgString => {
                    displaySvg(svgString);
                })
                .catch(e => {
                    showError('Error loading map.svg: ' + e.message + '. Please ensure map.svg is in the same directory as this HTML file and the "flags" folder with images exists.');
                });

            function displaySvg(svgString) {
                // Clear previous SVG content
                svgDisplayArea.innerHTML = '';

                // Create a temporary div to parse the SVG string into DOM elements
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = svgString;
                const svgElement = tempDiv.querySelector('svg');

                if (!svgElement) {
                    showError('Invalid SVG file. Could not find SVG element.');
                    return;
                }

                // Append the SVG element to the display area
                svgDisplayArea.appendChild(svgElement);

                // Process territories to apply flag patterns or solid colors
                processTerritories(svgElement);
                // Attach event listeners after processing
                attachSvgInteractions(svgElement);
            }

            function attachSvgInteractions(svgElement) {
                const allPaths = svgElement.querySelectorAll('path');

                allPaths.forEach(path => {
                    // Store original stroke properties for hover effect
                    path.dataset.originalStroke = path.getAttribute('stroke');
                    path.dataset.originalStrokeWidth = path.getAttribute('stroke-width');

                    // Set line join and cap for smoother borders
                    path.setAttribute('stroke-linejoin', 'round');
                    path.setAttribute('stroke-linecap', 'round');

                    // Add event listeners for hover and click
                    path.addEventListener('mouseover', handleMouseOver);
                    path.addEventListener('mouseout', handleMouseOut);
                    path.addEventListener('click', handlePathClick);
                });
            }

            function handleMouseOver(event) {
                const hoveredPath = event.target;
                const hoveredName = hoveredPath.dataset.name;
                const hoveredPower = hoveredPath.dataset.power;
                const hoveredIpcs = hoveredPath.dataset.ipcs;

                // Find all paths belonging to the same logical territory
                const allPaths = svgDisplayArea.querySelectorAll('path');
                allPaths.forEach(path => {
                    if (path.dataset.name === hoveredName &&
                        path.dataset.power === hoveredPower &&
                        path.dataset.ipcs === hoveredIpcs) {
                        path.setAttribute('stroke-width', '3'); // Highlight stroke width
                        path.setAttribute('stroke', '#000000'); // Highlight stroke color
                    }
                });
            }

            function handleMouseOut(event) {
                const hoveredPath = event.target;
                const hoveredName = hoveredPath.dataset.name;
                const hoveredPower = hoveredPath.dataset.power;
                const hoveredIpcs = hoveredPath.dataset.ipcs;

                // Revert all paths belonging to the same logical territory to original style
                const allPaths = svgDisplayArea.querySelectorAll('path');
                allPaths.forEach(path => {
                    if (path.dataset.name === hoveredName &&
                        path.dataset.power === hoveredPower &&
                        path.dataset.ipcs === hoveredIpcs) {
                        // Only revert if not currently selected
                        if (!selectedPaths.includes(path)) {
                            path.setAttribute('stroke-width', path.dataset.originalStrokeWidth);
                            path.setAttribute('stroke', path.dataset.originalStroke);
                        }
                    }
                });
            }

            function handlePathClick(event) {
                const clickedPath = event.target;
                const clickedName = clickedPath.dataset.name;
                const clickedPower = clickedPath.dataset.power;
                const clickedIpcs = clickedPath.dataset.ipcs;

                const allPaths = svgDisplayArea.querySelectorAll('path');
                const territoryPaths = Array.from(allPaths).filter(path =>
                    path.dataset.name === clickedName &&
                    path.dataset.power === clickedPower &&
                    path.dataset.ipcs === clickedIpcs
                );

                // Check if the clicked territory is already selected
                const isAlreadySelected = selectedPaths.length > 0 &&
                                         selectedPaths[0].dataset.name === clickedName &&
                                         selectedPaths[0].dataset.power === clickedPower &&
                                         selectedPaths[0].dataset.ipcs === clickedIpcs;

                // Deselect all currently selected paths
                selectedPaths.forEach(path => {
                    if (originalFills.has(path)) {
                        path.setAttribute('fill', originalFills.get(path));
                    }
                    // Also revert stroke if it was highlighted by hover
                    path.setAttribute('stroke-width', path.dataset.originalStrokeWidth);
                    path.setAttribute('stroke', path.dataset.originalStroke);
                });
                selectedPaths = [];
                originalFills.clear();

                if (!isAlreadySelected) {
                    // Select the new territory
                    territoryPaths.forEach(path => {
                        originalFills.set(path, path.getAttribute('fill')); // Store original fill (could be pattern URL)
                        path.setAttribute('fill', '#FFFF00'); // Bright yellow
                    });
                    selectedPaths = territoryPaths;
                }
            }

            function processTerritories(svgElement) {
                const defs = svgElement.querySelector('defs') || svgElement.insertBefore(document.createElementNS('http://www.w3.org/2000/svg', 'defs'), svgElement.firstChild);

                // --- SVG Filter for Wave Animation ---
                // Add this filter definition once
                if (!defs.querySelector('#waveFilter')) {
                    const waveFilter = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
                    waveFilter.setAttribute('id', 'waveFilter');
                    waveFilter.setAttribute('x', '-50%'); // Extend filter area to avoid clipping at edges
                    waveFilter.setAttribute('y', '-50%');
                    waveFilter.setAttribute('width', '200%');
                    waveFilter.setAttribute('height', '200%');

                    const feTurbulence = document.createElementNS('http://www.w3.org/2000/svg', 'feTurbulence');
                    feTurbulence.setAttribute('type', 'fractalNoise');
                    feTurbulence.setAttribute('baseFrequency', '0.005 0.005');
                    feTurbulence.setAttribute('numOctaves', '1');
                    feTurbulence.setAttribute('result', 'turbulence');

                    // Animate the baseFrequency for subtle wave motion
                    const animateTurbulence = document.createElementNS('http://www.w3.org/2000/svg', 'animate');
                    animateTurbulence.setAttribute('attributeName', 'baseFrequency');
                    animateTurbulence.setAttribute('from', '0.005 0.005');
                    animateTurbulence.setAttribute('to', '0.015 0.015');
                    animateTurbulence.setAttribute('dur', '30s'); // Very slow animation
                    animateTurbulence.setAttribute('repeatCount', 'indefinite');
                    feTurbulence.appendChild(animateTurbulence);

                    const feDisplacementMap = document.createElementNS('http://www.w3.org/2000/svg', 'feDisplacementMap');
                    feDisplacementMap.setAttribute('in', 'SourceGraphic');
                    feDisplacementMap.setAttribute('in2', 'turbulence');
                    feDisplacementMap.setAttribute('scale', '5'); // Adjust scale for wave intensity
                    feDisplacementMap.setAttribute('xChannelSelector', 'R');
                    feDisplacementMap.setAttribute('yChannelSelector', 'G');

                    waveFilter.appendChild(feTurbulence);
                    waveFilter.appendChild(feDisplacementMap);
                    defs.appendChild(waveFilter);
                }

                // --- Radial Gradient for Ocean Depth ---
                if (!defs.querySelector('#oceanDepthGradient')) {
                    const radialGradient = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
                    radialGradient.setAttribute('id', 'oceanDepthGradient');
                    radialGradient.setAttribute('cx', '50%');
                    radialGradient.setAttribute('cy', '50%');
                    radialGradient.setAttribute('r', '50%');
                    radialGradient.setAttribute('fx', '50%');
                    radialGradient.setAttribute('fy', '50%');

                    const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                    stop1.setAttribute('offset', '0%');
                    stop1.setAttribute('stop-color', '#1a202c'); // Dark blue from body background
                    stop1.setAttribute('stop-opacity', '0'); // Center: fully transparent

                    const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                    stop2.setAttribute('offset', '70%');
                    stop2.setAttribute('stop-color', '#1a202c');
                    stop2.setAttribute('stop-opacity', '0.5'); // Mid-way: semi-opaque

                    const stop3 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                    stop3.setAttribute('offset', '100%');
                    stop3.setAttribute('stop-color', '#1a202c');
                    stop3.setAttribute('stop-opacity', '0.8'); // Edge: more opaque

                    radialGradient.appendChild(stop1);
                    radialGradient.appendChild(stop2);
                    radialGradient.appendChild(stop3);
                    defs.appendChild(radialGradient);
                }

                // --- Create Ocean Pattern ---
                const oceanPatternId = 'ocean-pattern';
                // Remove previous ocean pattern if it exists to recreate with new effects
                let existingOceanPattern = defs.querySelector(`#${oceanPatternId}`);
                if (existingOceanPattern) {
                    existingOceanPattern.remove();
                }

                const oceanPattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
                oceanPattern.setAttribute('id', oceanPatternId);
                oceanPattern.setAttribute('patternUnits', 'userSpaceOnUse');
                oceanPattern.setAttribute('width', '200'); // Adjust for desired repeat size of ocean texture
                oceanPattern.setAttribute('height', '200');
                oceanPattern.setAttribute('viewBox', '0 0 200 200');
                oceanPattern.setAttribute('preserveAspectRatio', 'xMidYMid slice'); // Cover, crop if needed

                const oceanImage = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                oceanImage.setAttribute('href', 'flags/ocean.png'); // Path to ocean.png
                oceanImage.setAttribute('x', '0');
                oceanImage.setAttribute('y', '0');
                oceanImage.setAttribute('width', '200');
                oceanImage.setAttribute('height', '200');
                oceanImage.setAttribute('preserveAspectRatio', 'xMidYMid slice'); // Ensure image covers pattern area
                oceanImage.setAttribute('filter', 'url(#waveFilter)'); // Apply the wave filter

                // Darkening overlay (can be adjusted or removed if radial gradient handles enough)
                const oceanOverlay = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                oceanOverlay.setAttribute('x', '0');
                oceanOverlay.setAttribute('y', '0');
                oceanOverlay.setAttribute('width', '200');
                oceanOverlay.setAttribute('height', '200');
                oceanOverlay.setAttribute('fill', 'black');
                oceanOverlay.setAttribute('opacity', '0.1'); // Adjust opacity for desired darkening

                // Radial gradient rect for depth effect
                const oceanDepthRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                oceanDepthRect.setAttribute('x', '0');
                oceanDepthRect.setAttribute('y', '0');
                oceanDepthRect.setAttribute('width', '200');
                oceanDepthRect.setAttribute('height', '200');
                oceanDepthRect.setAttribute('fill', 'url(#oceanDepthGradient)');
                oceanDepthRect.setAttribute('opacity', '0.4'); // Adjust opacity for desired depth blend

                oceanPattern.appendChild(oceanImage);
                oceanPattern.appendChild(oceanOverlay); // Add black overlay after image
                oceanPattern.appendChild(oceanDepthRect); // Add depth gradient after black overlay
                defs.appendChild(oceanPattern);


                const allPaths = svgElement.querySelectorAll('path');
                const eligibleTerritories = []; // Paths that can have flags

                allPaths.forEach(path => {
                    const power = path.dataset.power;
                    const name = path.dataset.name;
                    const currentFill = path.getAttribute('fill');
                    const isSeaZone = currentFill === '#e0f2f7'; // Matches the sea zone color from the converter

                    if (power && power !== "Neutral" && power !== "Impassable") {
                        const shouldHaveFlag = (
                            (power === "US" && flagTerritories["US"].includes(name)) ||
                            (power === "UK" && flagTerritories["UK"].includes(name)) ||
                            (power === "Germany" && flagTerritories["Germany"].includes(name)) ||
                            (power === "Italy" && flagTerritories["Italy"].includes(name)) ||
                            (power === "Commonwealth" && flagTerritories["Commonwealth"].includes(name)) ||
                            (power === "France" && flagTerritories["France"].includes(name)) ||
                            (power === "China") || // Unchanged for China
                            (power === "Japan") || // Unchanged for Japan
                            (power === "USSR")    // Unchanged for Soviet Union
                        );

                        if (shouldHaveFlag) {
                            try {
                                const bbox = path.getBBox();
                                eligibleTerritories.push({
                                    path: path,
                                    bbox: bbox,
                                    name: name,
                                    power: power,
                                    ipcs: path.dataset.ipcs,
                                    id: `${name}_${power}_${path.dataset.ipcs}_${Math.random().toString(36).substr(2, 9)}`
                                });
                            } catch (e) {
                                console.warn("Could not get BBox for path:", path, e);
                            }
                        } else {
                            // If it shouldn't have a flag, fill with its pastel color
                            path.setAttribute('fill', powerColors[power] || currentFill);
                        }
                    } else {
                        // For Neutral and Impassable land territories, use the new darker pastel color fill
                        path.setAttribute('fill', powerColors[power] || currentFill);
                    }
                });

                // Group adjacent/near-adjacent territories of the same power
                const groupedTerritories = groupAdjacentTerritories(eligibleTerritories, 30); // 30px threshold for adjacency

                // Apply flag patterns to grouped territories
                groupedTerritories.forEach(group => {
                    if (group.paths.length === 0) return;

                    const groupPower = group.power;
                    const flagFileName = `${groupPower}.png`;
                    const flagPath = `flags/${flagFileName}`;

                    // Calculate combined bounding box for the group
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    group.paths.forEach(item => {
                        minX = Math.min(minX, item.bbox.x);
                        minY = Math.min(minY, item.bbox.y);
                        maxX = Math.max(maxX, item.bbox.x + item.bbox.width);
                        maxY = Math.max(maxY, item.bbox.y + item.bbox.height);
                    });

                    const combinedBBoxWidth = maxX - minX;
                    const combinedBBoxHeight = maxY - minY;

                    if (combinedBBoxWidth <= 0 || combinedBBoxHeight <= 0) {
                        console.warn("Invalid combined bounding box for group:", group);
                        return; // Skip if bounding box is invalid
                    }

                    const patternId = `flag-pattern-group-${group.id}`.replace(/[^a-zA-Z0-9-]/g, '_');

                    const pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
                    pattern.setAttribute('id', patternId);
                    pattern.setAttribute('patternUnits', 'userSpaceOnUse'); // Use userSpaceOnUse to position pattern relative to SVG coordinates
                    pattern.setAttribute('x', minX);
                    pattern.setAttribute('y', minY);
                    pattern.setAttribute('width', combinedBBoxWidth);
                    pattern.setAttribute('height', combinedBBoxHeight);
                    pattern.setAttribute('viewBox', `0 0 ${combinedBBoxWidth} ${combinedBBoxHeight}`); // ViewBox for the image within the pattern

                    const image = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                    image.setAttribute('href', flagPath);
                    image.setAttribute('x', '0');
                    image.setAttribute('y', '0');
                    image.setAttribute('width', combinedBBoxWidth);
                    image.setAttribute('height', combinedBBoxHeight);
                    image.setAttribute('preserveAspectRatio', 'none'); // Force image to stretch to fill the pattern area

                    // --- Darkening Gradient Overlay for Flags ---
                    const gradientId = `darken-gradient-${patternId}`;
                    const linearGradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
                    linearGradient.setAttribute('id', gradientId);
                    linearGradient.setAttribute('x1', '0%');
                    linearGradient.setAttribute('y1', '0%');
                    linearGradient.setAttribute('x2', '100%'); // Gradient from left to right for progressive darkening
                    linearGradient.setAttribute('y2', '0%');

                    const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                    stop1.setAttribute('offset', '0%');
                    stop1.setAttribute('stop-color', 'black');
                    stop1.setAttribute('stop-opacity', '0.2'); // Start slightly opaque for more faded effect

                    const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                    stop2.setAttribute('offset', '100%');
                    stop2.setAttribute('stop-color', 'black');
                    stop2.setAttribute('stop-opacity', '0.6'); // End with more opacity for more faded effect

                    linearGradient.appendChild(stop1);
                    linearGradient.appendChild(stop2);
                    defs.appendChild(linearGradient);

                    const overlayRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    overlayRect.setAttribute('x', '0');
                    overlayRect.setAttribute('y', '0');
                    overlayRect.setAttribute('width', combinedBBoxWidth);
                    overlayRect.setAttribute('height', combinedBBoxHeight);
                    overlayRect.setAttribute('fill', `url(#${gradientId})`);
                    overlayRect.setAttribute('pointer-events', 'none'); // Ensure overlay doesn't interfere with clicks

                    pattern.appendChild(image);
                    pattern.appendChild(overlayRect); // Add overlay after the image
                    defs.appendChild(pattern);

                    // Apply this pattern to all paths in the group
                    group.paths.forEach(item => {
                        item.path.setAttribute('fill', `url(#${patternId})`);
                    });
                });
            }

            // Helper function to calculate distance between two bounding boxes
            function getBoundingBoxDistance(bbox1, bbox2) {
                // Calculate the horizontal and vertical overlap/gap
                const dx = Math.max(0, bbox1.x - (bbox2.x + bbox2.width), bbox2.x - (bbox1.x + bbox1.width));
                const dy = Math.max(0, bbox1.y - (bbox2.y + bbox2.height), bbox2.y - (bbox1.y + bbox1.height));
                // Return the Euclidean distance between the closest points of the bounding boxes
                return Math.sqrt(dx * dx + dy * dy);
            }

            // Function to group territories based on adjacency and power using a BFS-like approach
            function groupAdjacentTerritories(territories, threshold) {
                const groups = [];
                const visited = new Set(); // Keep track of territories already added to a group

                territories.forEach(territory => {
                    if (!visited.has(territory.id)) {
                        const currentGroup = {
                            power: territory.power,
                            paths: [], // Stores the eligibleTerritory objects (with path, bbox, etc.)
                            id: `group_${Math.random().toString(36).substr(2, 9)}` // Unique ID for the group
                        };
                        const queue = [territory]; // Start BFS from this territory
                        visited.add(territory.id);

                        while (queue.length > 0) {
                            const current = queue.shift();
                            currentGroup.paths.push(current);

                            // Check for adjacent territories of the same power
                            territories.forEach(other => {
                                if (!visited.has(other.id) &&
                                    other.power === current.power &&
                                    getBoundingBoxDistance(current.bbox, other.bbox) <= threshold) {
                                    visited.add(other.id);
                                    queue.push(other);
                                }
                            });
                        }
                        groups.push(currentGroup);
                    }
                });
                return groups;
            }
        });
    </script>
</body>
</html>