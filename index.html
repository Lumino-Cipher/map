<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editable Full Screen SVG Viewer</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            background-color: #282c34;
            font-family: Arial, sans-serif;
            color: #f0f0f0;
        }

        .svg-wrapper {
            display: block; 
            width: 100%;
            position: relative; 
        }

        /* Style for the SVG element itself */
        .svg-content {
            display: block; /* Ensure it behaves as a block element */
            /* width and height will be set dynamically by JS based on zoom, matching scaledViewBox */
            object-fit: contain; /* Not strictly necessary if width/height are explicitly set by JS */
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }


        /* Styles for the resize slider */
        .resize-slider-container {
            position: absolute;
            top: 20px; /* Adjust as needed */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(44, 44, 44, 0.9);
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            display: none; /* Hidden by default */
            z-index: 1000;
            white-space: nowrap;
        }

        .resize-slider-container label {
            margin-right: 10px;
            font-size: 14px;
            color: #ccc;
        }

        .resize-slider-container input[type="range"] {
            width: 150px;
            height: 8px;
            background: #555;
            border-radius: 5px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            cursor: grab;
        }

        .resize-slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #007bff;
            cursor: grab;
            box-shadow: 0 0 5px rgba(0, 123, 255, 0.5);
            transition: background 0.2s ease-in-out;
        }

        .resize-slider-container input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #007bff;
            cursor: grab;
            box-shadow: 0 0 5px rgba(0, 123, 255, 0.5);
            transition: background 0.2s ease-in-out;
        }

        .resize-slider-container input[type="range"]::-webkit-slider-thumb:active,
        .resize-slider-container input[type="range"]::-moz-range-thumb:active {
            cursor: grabbing;
        }

        /* Styles for control buttons */
        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 1001;
        }

        .controls button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s ease;
        }

        .controls button:hover {
            background-color: #0056b3;
        }

        /* Style for editable text elements */
        .editable-text {
            cursor: grab; /* Indicates draggable */
        }
        .editable-text:active {
            cursor: grabbing;
        }
        .svg-wrapper::-webkit-scrollbar {
            display: none; /* Hide the now-redundant scrollbar */
        }

        .svg-wrapper::-webkit-scrollbar-track {
            background: linear-gradient(135deg, #2c2c34, #3a3f47);
            border: 2px solid #22252a;
            border-radius: 12px;
            box-shadow: inset 0 0 6px rgba(0,0,0,0.3);
        }

        .svg-wrapper::-webkit-scrollbar-thumb {
            background: linear-gradient(45deg, #007bff, #66ccff); /* Your blue gradient */
            border-radius: 12px;
            border: 3px solid #282c34; /* Border matching body background */
            box-shadow: 0 0 10px rgba(0, 123, 255, 0.7), inset 0 0 6px rgba(0,0,0,0.3);
        }

        .svg-wrapper::-webkit-scrollbar-corner {
            background: #282c34;
        }

        /* Custom Scrollbar Styling for Firefox */
        html { /* Firefox scrollbar properties are global and apply to the main document scrollbars */
            scrollbar-color: #007bff #2c2c34; /* thumb-color track-color */
            scrollbar-width: thin;
        }

        /* Highlight style for the territory when a unit is dragged */
        .highlighted-territory {
            stroke: #FFFF00 !important; /* Bright yellow border */
            stroke-width: 3 !important; /* Thicker border */
            fill-opacity: 1.0 !important; /* Ensure it's fully visible */
        }

        /* Updated styles for IPC display bar */
        .ipc-display-bar {
            position: sticky;
            bottom: 0;
            z-index: 100;            
            display: flex;
            justify-content: flex-start;
            align-items: center; 
            padding: 5px 0; /* Added a little vertical padding */
            background-color: rgba(30, 30, 30, 0.9);
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.5);
            overflow-y: hidden;
            white-space: nowrap; 
            box-sizing: border-box;
        }
        .ipc-square {
            box-sizing: border-box; /* <-- ADD THIS LINE */
            flex-shrink: 0;
            margin: 0;
            border: 1px solid #555;
            border-radius: 3px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: 'Times New Roman', serif;
            color: #E0D8B0;
            background: #6D5C4C;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5), 1px 1px 3px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
            text-align: center;
            cursor: default;
            transition: transform 0.1s ease-in-out;
            font-size: 14px; /* Smaller font for numbers */
            font-weight: bold;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.7);
        }

        .ipc-square:hover {
            transform: translateY(-2px);
        }

        .ipc-square::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('https://www.transparenttextures.com/patterns/cream-paper.png');
            opacity: 0.15;
            pointer-events: none;
            z-index: 1;
        }

        .ipc-square .ipc-number {
            position: relative; /* Ensure number is above flag if needed */
            z-index: 4; /* Higher z-index for the number */
            background-color: rgba(60, 50, 40, 0.5); /* Semi-transparent background for readability */
            padding: 2px 4px;
            border-radius: 3px;
        }

        /* Container for multiple flags */
        .ipc-flags-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            z-index: 2; /* Below the number, above the texture */
            overflow: hidden; /* Ensure flags stay within bounds */
        }

        .ipc-flags-container.vertical-split {
            flex-direction: column; /* Stack flags vertically */
        }

        .ipc-flags-container.horizontal-split {
            flex-direction: row; /* Lay out flags horizontally */
        }

        .ipc-flags-container .flag-item {
            display: flex; /* Use flex for individual flag containers */
            justify-content: center;
            align-items: center;
            overflow: hidden; /* Important for cropping */
        }

        .vertical-split .flag-item {
            flex: 1; /* Each flag takes equal vertical space */
            width: 100%; /* Each flag item spans full width */
        }

        .horizontal-split .flag-item {
            flex: 1; /* Each flag takes equal horizontal space */
            height: 100%; /* Each flag item spans full height */
        }


        .flag-item .flag-icon {
            width: 100%;
            height: 100%;
            object-fit: fill; /* Crop to fill the split section */
            opacity: 0.6; /* Transparent overlay */
            mix-blend-mode: screen; /* Optional: experiment with blend modes for vintage look */
        }

        /* Styles for the new R&D Display Bar */
        .rd-display-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            padding: 10px 0;
            background-color: #282c34; /* Match the main background color */
            height: 80px;
            width: 100%;
            box-sizing: border-box;
            margin-top: 15px; /* Add some space above the bar */
        }

        /* Add this new class for the USSR flag crop */
        .rd-flag-ussr {
            background-position: left center !important; /* Crop from the left */
        }

        .rd-power-card {
            width: 60px;
            height: 60px;
            position: relative; /* For positioning the text overlay */
            background-color: #444;
            border-radius: 50%; /* Make the card itself a circle to contain the flag */
            box-shadow: 0 2px 5px rgba(0,0,0,0.4);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .rd-flag-circle {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background-size: cover; /* This zooms and crops the image */
            background-position: center center; /* This centers the crop */
            overflow: hidden; /* Ensures nothing spills out */
        }

        .rd-stage-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px black;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
            pointer-events: none; /* So it doesn't interfere with clicks */
        }

        /* Add styles for the new container and move scrollbar styles to it */
        #map-container {
            flex: 1 1 auto; /* Make the map container grow to fill available space */
            overflow: auto; /* Allow scrolling in BOTH directions */
            position: relative; /* Essential for the sticky child to work correctly */
            width: 100%;
        }

        /* Move scrollbar styling from .svg-wrapper to #map-container */
        #map-container::-webkit-scrollbar {
            width: 16px;
            height: 16px;
        }

        #map-container::-webkit-scrollbar-track {
            background: linear-gradient(135deg, #2c2c34, #3a3f47);
            border: 2px solid #22252a;
            border-radius: 12px;
            box-shadow: inset 0 0 6px rgba(0,0,0,0.3);
        }

        #map-container::-webkit-scrollbar-thumb {
            background: linear-gradient(45deg, #007bff, #66ccff);
            border-radius: 12px;
            border: 3px solid #282c34;
            box-shadow: 0 0 10px rgba(0, 123, 255, 0.7), inset 0 0 6px rgba(0,0,0,0.3);
        }

        #map-container::-webkit-scrollbar-corner {
            background: #282c34;
        }

        html {
            height: 100%; /* Ensure html element fills the viewport */
        }

        body {
            height: 100vh; /* Make body fill the viewport height */
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Prevent body itself from scrolling */
        }

        /* This is the new container for content below the map */
        #page-content {
            flex-shrink: 0; /* Prevent this container from shrinking */
            overflow-y: auto; /* Allow this section to scroll if its content is tall */
            padding-bottom: 20px;
        }

        .other-label {
            position: absolute;
            /* Ensure these labels are in the same layer as units */
            z-index: 5;
            /* This will be set by JS */
        }

        .victory-city-text {
            font-family: 'Times New Roman', serif;
            font-size: 10px;
            font-weight: bold;
            fill: yellow;
            /* The color of the text */
            stroke: black;
            /* Outline color */
            stroke-width: 0.7px;
            /* Outline thickness */
            pointer-events: none;
            text-transform: uppercase;
        }
        .neutral-flag-rect-frame {
            fill: none;
            stroke: #000000; /* A bright gold/yellow for high visibility */
            stroke-width: 2px;   /* Thicker outline */
        }
        /* Sticky Top Bar Styles */
        .sticky-top-bar {
            position: sticky;
            top: 0;
            width: 100%;
            height: 40px; /* Keeping it thin as requested */
            background-color: rgba(30, 30, 30, 0.95); /* Slightly darker background */
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center; /* Changed from space-around to center */
            align-items: center;
            padding: 0 10px;
            box-sizing: border-box;
            z-index: 1002; /* Higher than other fixed/sticky elements */
            color: #f0f0f0;
            font-family: Arial, sans-serif;
            font-size: 14px;
            gap: 20px; /* Add a gap between sections */
        }

        .sticky-top-bar .icon {
            font-size: 20px;
            cursor: pointer;
            color: #007bff;
            padding: 5px;
        }

        .sticky-top-bar .icon:hover {
            color: #66ccff;
        }

        .game-info-section {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 0 5px;
            border-right: 1px solid rgba(255, 255, 255, 0.1); /* Separator */
            height: 100%; /* Ensure separator spans height */
        }

        .game-info-section:last-child {
            border-right: none; /* No separator for the last item */
        }

        .round-info, .game-timer {
            white-space: nowrap;
        }

        /* Power Order Flags */
        .power-order {
            display: flex;
            gap: 2px;
        }

        .power-flag {
            width: 24px; /* Size of flag */
            height: 16px;
            border: 1px solid #555;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
            background-size: cover;
            background-position: center;
            border-radius: 2px;
            transition: transform 0.2s ease-in-out, border-color 0.2s ease-in-out;
        }

        .power-flag.current-turn {
            border: 2px solid yellow; /* Yellow circle for current turn */
            transform: scale(1.2);
            box-shadow: 0 0 8px rgba(255, 255, 0, 0.7);
        }

        /* Phase Display */
        .phase-display {
            position: relative;
            padding-top: 0px; /* Space for phase name above dots */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .phase-name {
            position: absolute;
            top: 2px;
            font-size: 12px;
            font-weight: bold;
            color: #f0f0f0;
            white-space: nowrap;
        }

        .phase-dots {
            display: flex;
            gap: 4px;
            margin-top: 5px;
        }

        .phase-dot {
            width: 8px;
            height: 8px;
            background-color: #555; /* Gray for inactive */
            border-radius: 50%;
            transition: background-color 0.2s ease-in-out;
        }

        .phase-dot.active {
            background-color: yellow; /* Yellow for active */
        }

        /* Victory Cities Display */
        .victory-cities-display {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
        }

        .vc-bar-container {
            display: flex;
            width: 114px; /* 19 cities * 6px width per city */
            height: 12px;
            border: 1px solid #555;
            border-radius: 3px;
            overflow: hidden;
        }

        .vc-bar {
            height: 100%;
        }

        .vc-bar.axis {
            background-color: #000000;
        }

        .vc-bar.allies {
            background-color: #ffffff;
        }

        .vc-count {
            font-size: 11px;
            white-space: nowrap;
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 900px) { /* Adjust breakpoint as needed */
            .game-info-section {
                border-right: none; /* Remove separators on smaller screens if they clutter */
                padding: 0 2px; /* Reduce padding */
                gap: 4px; /* Reduce internal gap */
            }

            .sticky-top-bar {
                font-size: 12px; /* Smaller font size */
                height: 35px; /* Slightly thinner */
                gap: 10px; /* Smaller gap between sections */
            }

            /* Hide all power flags except the current one */
            .power-flag:not(.current-turn) {
                display: none;
            }

            /* Make the current turn flag slightly larger and more prominent on smaller screens */
            .power-flag.current-turn {
                width: 32px; /* Increase size */
                height: 20px;
                transform: none; /* Remove scaling to fit better, border is enough */
                border: 2px solid yellow;
            }

            /* Adjust padding for phase name to prevent overlap if it's too long */
            .phase-display {
                padding-top: 10px;
            }
            .phase-name {
                font-size: 10px;
            }
            .phase-dot {
                width: 6px;
                height: 6px;
            }

            .vc-bar-container {
                width: 95px; /* Slightly smaller bar */
                height: 10px;
            }
            .vc-count {
                font-size: 10px;
            }
        }

        @media (max-width: 600px) { /* Even smaller screens, reduce font/element sizes further */
            .sticky-top-bar {
                font-size: 10px;
                height: 30px;
                gap: 5px;
            }
            .sticky-top-bar .icon {
                font-size: 16px;
            }
            .power-flag.current-turn {
                width: 28px;
                height: 18px;
            }
            .vc-count {
                font-size: 9px;
            }
            .vc-bar-container {
                width: 80px;
            }
        }

        /* ==================================================== */
        /* ==   VINTAGE BROWN THEME SIDE TABS AND PANELS     == */
        /* ==================================================== */

        .side-tabs-container {
            position: fixed;
            top: 50%;
            right: 0;
            transform: translateY(-50%);
            z-index: 1005;
            display: flex;
            flex-direction: column; /* This keeps the tabs stacked vertically */
            gap: 2px;
        }

        .side-tab {
            background-color: #6D5C4C; /* Dark, woody brown */
            color: #E0D8B0; /* Creamy off-white text */
            padding: 5px;
            cursor: pointer;
            border: 2px solid rgba(224, 216, 176, 0.2);
            border-right: none;
            border-radius: 10px 0 0 10px;
            box-shadow: -2px 2px 5px rgba(0,0,0,0.3);
            transition: background-color 0.2s ease;
            font-weight: bold;
            font-family: 'Times New Roman', serif; /* Vintage font */
            white-space: nowrap; /* Ensures text stays on one line */
            height: 10px;
        }

        .side-tab:hover {
            background-color: #8C7B6A; /* A slightly lighter brown for hover */
        }

        .draggable-panel {
            display: none; /* This correctly hides the panel by default */
            position: absolute;
            top: 20px; /* Initial top position */
            right: 20px; /* Position from the right edge */
            left: unset; /* Ensure left is not conflicting with right */
            width: 450px; /* Keep existing width */
            height: auto; /* Allow height to adjust based on content and max-height */
            min-width: 250px;
            min-height: 150px;
            max-height: calc(100vh - 80px); /* Limit height: 100vh - (top bar height + some padding) */
            border: 1px solid #8C7B6A;
            border-radius: 8px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.6);
            z-index: 1004;
            flex-direction: column;
            resize: both;
            overflow: hidden; /* Ensure content is clipped if overflow */
            color: #E0D8B0;
            font-family: 'Georgia', serif;
            background-color: rgba(45, 35, 25, 0.97); /* Keep your base background color */
            background-image: url('https://www.transparenttextures.com/patterns/paper.png'); /* Or use a local path to your texture */
            background-blend-mode: overlay; /* Adjust blend mode for desired effect (e.g., multiply, screen, overlay) */
        }

        /* Vintage paper texture overlay */
        .draggable-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: url('https://www.transparenttextures.com/patterns/cream-paper.png');
            opacity: 0.1;
            pointer-events: none; /* Allows clicks to go through to the content */
            z-index: -1;
        }

        /* Visible handle for resizing the panel */
        .draggable-panel::after {
            content: '';
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 15px;
            height: 15px;
            background:
                linear-gradient(135deg, rgba(224, 216, 176, 0) 0%, rgba(224, 216, 176, 0) 45%, rgba(224, 216, 176, 0.7) 50%, rgba(224, 216, 176, 0) 55%, rgba(224, 216, 176, 0) 100%),
                linear-gradient(135deg, rgba(224, 216, 176, 0.7) 0%, rgba(224, 216, 176, 0) 10%, rgba(224, 216, 176, 0) 100%);
            cursor: se-resize;
            pointer-events: none; /* Allows the browser's resize to work underneath */
        }


        .draggable-panel.visible {
            display: flex;
        }

        .panel-header {
            background-color: #6D5C4C; /* Dark, woody brown */
            color: #E0D8B0;
            padding: 8px 12px;
            font-weight: bold;
            cursor: move;
            border-top-left-radius: 7px;
            border-top-right-radius: 7px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #8C7B6A;
            font-family: 'Times New Roman', serif;
        }

        .close-panel {
            cursor: pointer;
            font-size: 16px;
            font-family: Arial, sans-serif;
            padding: 2px 6px;
            border-radius: 50%;
        }

        .close-panel:hover {
            background-color: rgba(224, 216, 176, 0.2); /* Creamy highlight */
        }

        .panel-content {
            padding: 15px;
            flex-grow: 1;
            overflow-y: auto;
            /* Custom scrollbar for vintage feel */
            scrollbar-color: #6D5C4C #4a3f35; /* thumb track */
            scrollbar-width: thin;
        }

        .panel-content ul {
            padding-left: 20px;
        }
    </style>
</head>
<body>
    <div id="stickyTopBar" class="sticky-top-bar">
        <div class="icon">⚙️</div> <div id="roundInfo" class="game-info-section round-info">
            Round: 1 (May 10, 1940)
        </div>

        <div id="gameTimer" class="game-info-section game-timer">
            Time: 00:00:00
        </div>

        <div id="powerOrder" class="game-info-section power-order">
            <div class="power-flag" style="background-image: url('flags/Germany.png');"></div>
            <div class="power-flag" style="background-image: url('flags/Japan.png');"></div>
            <div class="power-flag current-turn" style="background-image: url('flags/US.png');"></div>
            <div class="power-flag" style="background-image: url('flags/UK.png');"></div>
            <div class="power-flag" style="background-image: url('flags/China.png');"></div>
            <div class="power-flag" style="background-image: url('flags/Italy.png');"></div>
            <div class="power-flag" style="background-image: url('flags/Commonwealth.png');"></div>
            <div class="power-flag" style="background-image: url('flags/France.png');"></div>
            <div class="power-flag" style="background-image: url('flags/USSR.png');"></div>
        </div>

        <div id="phaseDisplay" class="game-info-section phase-display">
            <div class="phase-name">Technology Research</div>
            <div class="phase-dots">
                <div class="phase-dot active"></div>
                <div class="phase-dot"></div>
                <div class="phase-dot"></div>
                <div class="phase-dot"></div>
                <div class="phase-dot"></div>
                <div class="phase-dot"></div>
                <div class="phase-dot"></div>
            </div>
        </div>

        <div id="victoryCitiesDisplay" class="game-info-section victory-cities-display">
            <div class="vc-count">VCs: 10 (Axis) - 9 (Allies)</div>
            <div class="vc-bar-container">
                <div class="vc-bar axis" style="width: 52.6%;"></div> <div class="vc-bar allies" style="width: 47.4%;"></div> </div>
        </div>
    </div>
    <div id="map-container">
        <div class="svg-wrapper" id="svgWrapper"></div>

        <div class="rd-display-bar" id="rdDisplayBar">
            <!-- Germany -->
            <div class="rd-power-card">
                <div class="rd-flag-circle" style="background-image: url('flags/Germany.png');"></div>
                <div class="rd-stage-text">P1</div>
            </div>
            <!-- Japan -->
            <div class="rd-power-card">
                <div class="rd-flag-circle" style="background-image: url('flags/Japan.png');"></div>
                <div class="rd-stage-text">P2</div>
            </div>
            <!-- Italy -->
            <div class="rd-power-card">
                <div class="rd-flag-circle" style="background-image: url('flags/Italy.png');"></div>
                <div class="rd-stage-text">P3</div>
            </div>
            <!-- USSR -->
            <div class="rd-power-card">
                <div class="rd-flag-circle rd-flag-ussr" style="background-image: url('flags/USSR.png');"></div>
                <div class="rd-stage-text">H</div>
            </div>
            <!-- US -->
            <div class="rd-power-card">
                <div class="rd-flag-circle" style="background-image: url('flags/US.png');"></div>
                <div class="rd-stage-text">A</div>
            </div>
            <!-- UK -->
            <div class="rd-power-card">
                <div class="rd-flag-circle" style="background-image: url('flags/UK.png');"></div>
                <div class="rd-stage-text">P1</div>
            </div>
            <!-- France -->
            <div class="rd-power-card">
                <div class="rd-flag-circle" style="background-image: url('flags/France.png');"></div>
                <div class="rd-stage-text">P1</div>
            </div>
        </div>
        <div class="ipc-display-bar" id="ipcDisplayBar"></div>
    </div>
    <div class="side-tabs-container">
        <div class="side-tab" data-target="panel-political">Political Situation</div>
        <div class="side-tab" data-target="panel-objectives">National Objectives</div>
        <div class="side-tab" data-target="panel-victory">Victory Points</div>
        <div class="side-tab" data-target="panel-war">War Status</div>
        <div class="side-tab" data-target="panel-purchased">Purchased Units</div>
        <div class="side-tab" data-target="panel-battle">Battle Simulator</div>
        <div class="side-tab" data-target="panel-notes">Notes</div>
    </div>

    <div id="panels-wrapper">
        <div id="panel-political" class="draggable-panel">
            <div class="panel-header">Political Situation <span class="close-panel">X</span></div>
            <div class="panel-content">
                <p>Placeholder for political rules, bullet points, etc.</p>
            </div>
        </div>

        <div id="panel-objectives" class="draggable-panel">
            <div class="panel-header">National Objectives <span class="close-panel">X</span></div>
            <div class="panel-content">
                <p>Placeholder for national objectives for each power.</p>
            </div>
        </div>

        <div id="panel-victory" class="draggable-panel">
            <div class="panel-header">Victory Points <span class="close-panel">X</span></div>
            <div class="panel-content">
                <h4>Axis Victory Conditions:</h4>
                <ul>
                    <li><b>Rounds Played:</b>
                        <ul>
                            <li>8 rounds: 12 victory points</li>
                            <li>9 rounds: 13 victory points</li>
                            <li>10 rounds: 14 victory points</li>
                        </ul>
                    </li>
                    <li><b>Victory Cities:</b> Each city held counts as one point.</li>
                    <li><b>World Oil 1:</b> Axis control 4 of 10 oil territories.</li>
                    <li><b>World Oil 2:</b> Axis control 8 of 10 oil territories.</li>
                    <li><b>Resources:</b> Axis control 3 of 5 resource territories.</li>
                    <li><b>Atlantic Wall:</b> Control Norway, Denmark, Normandy, Holland.</li>
                    <li><b>South Africa:</b> Control Union of South African and South West Africa.</li>
                    <li><b>South Asia:</b> Control Burma, Shan State, Thailand, Malaya, French Indo China.</li>
                    <li><b>Imperial:</b> Japan earns 55 IPCs.</li>
                    <li><b>China:</b> Control all Chinese marked territories.</li>
                    <li><b>Africa Horn:</b> Control Sudan, Kenya, Ethiopia, British Somaliland, Italian Somaliland.</li>
                    <li><b>Mediterranean:</b> No Allied territories in SZ 95-99, and also controlling at least three of the following: Egypt, Greece, Gibraltar, and Vichy France.</li>
                    <li><b>Pacific Islands:</b> Control 5 originally US, Commonwealth, or UK Pacific islands.</li>
                    <li><b>Reich:</b> Germany and Italy have a total of 70 IPCs together.</li>
                </ul>
            </div>
        </div>

        <div id="panel-war" class="draggable-panel">
            <div class="panel-header">War Status <span class="close-panel">X</span></div>
            <div class="panel-content">
                <p>Placeholder for war status display (flags, lines, etc.).</p>
            </div>
        </div>
        
        <div id="panel-purchased" class="draggable-panel">
            <div class="panel-header">Purchased Units <span class="close-panel">X</span></div>
            <div class="panel-content">
                 <p>Placeholder for a table of purchased units.</p>
            </div>
        </div>

        <div id="panel-battle" class="draggable-panel">
            <div class="panel-header">Battle Simulator <span class="close-panel">X</span></div>
            <div class="panel-content">
                <p>Placeholder for battle simulator inputs.</p>
            </div>
        </div>

        <div id="panel-notes" class="draggable-panel">
            <div class="panel-header">Notes <span class="close-panel">X</span></div>
            <div class="panel-content">
                <textarea style="width: 100%; height: 95%; box-sizing: border-box;"></textarea>
            </div>
        </div>
    </div>
    <script>
        const svgWrapper = document.getElementById('svgWrapper');
        let currentSvgElement = null; // Reference to the injected <svg> element
        let zoomLevel = 1.0;
        const zoomStep = 0.05;

        // Store original SVG viewBox and aspect ratio for proper scaling
        let originalViewBox = null;
        let originalAspectRatio = 1;

        // Editable text settings storage { "territoryName": { "x": 123, "y": 456, "fontSize": 14, "ipcsX": 100, "ipcsY": 400, "ipcsFontSize": 16, "words": [] } }
        const textSettings = {}; // This will now be populated from labels.json

        // Define your dark mode color palette for each data-power value
        const powerColors = {
            'US': '#4CAF50', // A muted green
            'UK': '#2199F3', // A soft blue
            'USSR': '#DC143C', // A crimson red
            'Germany': '#607D8B', // A dark grey-blue
            'Japan': '#FFC107', // A warm amber
            'Italy': '#9C27B0', // A muted purple
            'China': '#FF5722', // A burnt orange
            'Commonwealth': '#008B8B', // A dark cyan
            'France': '#3F51B5', // A deep indigo
            'Neutral': '#757575', // A standard neutral grey
            'Pro-Axis Neutral': '#C4A484', // A light brown for Pro-Axis
            'Pro-Allied Neutral': '#987654', // A darker brown for Pro-Allied
            'Impassable': '#333333' // Very dark for impassable areas
        };

        const LAND_UNIT_SIZE = 30; // SVG units for land unit image width/height
        const NEUTRAL_LAND_UNIT_SIZE = 45; // Larger size for neutral units

        // New mapping for specific sea unit sizes based on logical scale
        const SEA_UNIT_TYPE_SIZES = {
            'TPT': 45, // Transport baseline
            'SUB': 30, // Submarine: smaller than TPT
            'DTR': 40, // Destroyer: smaller than TPT, larger than SUB
            'CSR': 55, // Cruiser: larger than TPT
            'ACC': 70, // Aircraft Carrier: significantly larger
            'BTS': 75  // Battleship: largest
        };

        // Add these with your other global variables
        let setupData = null; // To store the loaded setup.json data
        const airUnitTypes = ['FTR', 'TBR', 'SBR']; // Fighter, Tactical Bomber, Strategic Bomber

        // Define sizes for special infrastructure units
        const MAJOR_IC_SIZE = 60; // 2 times larger than Minor IC
        const MINOR_IC_SIZE = 30; // Standard land unit size
        const AIR_BASE_SIZE = 45; // Larger than land units
        const NAVAL_BASE_SIZE = 45; // Larger than land units

        // Adjusted background circle radius (smaller and fixed)
        const UNIT_BACKGROUND_CIRCLE_RADIUS = 12;

        const UNIT_COUNT_CIRCLE_RADIUS = 5; // Smaller radius for the count circle below the unit
        const UNIT_COUNT_TEXT_FONT_SIZE = 8; // Smaller font size for the number inside the count circle

        const SPECIAL_UNIT_TEXT_FONT_SIZE = 8; // Font size for MAJOR, MINOR, AIR, SEA labels

        const INTER_UNIT_SPACING = 1; // Reduced spacing between unit groups/labels

        const UNIT_IMAGE_MAP = {
            'INF': 'units/infantry.png',
            'ART': 'units/artillery.png',
            'MECH': 'units/mechanized-infantry.png',
            'CAV': 'units/cavalry.png',
            'AAA': 'units/anti-aircraft.png',
            'TANK': 'units/tank.png',
            'FTR': 'units/fighter.png',
            'TBR': 'units/tactical-bomber.png',
            'SBR': 'units/strategic-bomber.png',
            'BTS': 'units/battleship.png',
            'ACC': 'units/aircraft-carrier.png',
            'CSR': 'units/cruiser.png',
            'DTR': 'units/destroyer.png',
            'TPT': 'units/transport.png',
            'SUB': 'units/submarine.png',
            "Air Base": 'units/air-base.png',
            "Naval Base": 'units/naval-base.png',
            "Major Industrial Complex": 'units/major-industrial-complex.png',
            "Minor Industrial Complex": 'units/minor-industrial-complex.png',
        };

        const SEA_UNIT_TYPES = ['BTS', 'ACC', 'CSR', 'DTR', 'TPT', 'SUB'];
        const SPECIAL_INFRASTRUCTURE_UNITS = ["Major Industrial Complex", "Minor Industrial Complex", "Air Base", "Naval Base"];


        // Global array to store current unit positions for saving/loading
        // Each item: { element: SVGElement, originalTerritory: string, placedIn: string, unitType: string, power: string, count: number, x: number, y: number }
        let placedUnitsData = [];

        let territoriesByCountry = {};

        // --- New Global Variables for Sticky Bar ---
        const gameStartDate = new Date('1940-05-10T00:00:00'); // May 10, 1940
        let gameStartTime = Date.now(); // Record when the game (page) started
        let currentRound = 1;
        let currentTurnPowerIndex = 0; // 0 for Germany, 1 for Japan, etc.
        let currentPhaseIndex = 0; // 0 for Technology Research, 1 for Purchase...

        const powersOrder = ['Germany', 'Japan', 'US', 'UK', 'China', 'Italy', 'Commonwealth', 'France', 'USSR'];
        const phaseNames = [
            'Technology Research',
            'Purchase / Repair / Demo Units',
            'Combat Movement',
            'Conduct Combat',
            'Noncombat Movement',
            'Mobilize New Units',
            'Collect Income'
        ];

        // --- Get elements for the sticky bar ---
        const roundInfoEl = document.getElementById('roundInfo');
        const gameTimerEl = document.getElementById('gameTimer');
        const powerOrderEl = document.getElementById('powerOrder');
        const phaseDisplayEl = document.getElementById('phaseDisplay');
        const victoryCitiesDisplayEl = document.getElementById('victoryCitiesDisplay');

        /**
         * Placeholder function to update round and date display.
         */
        function updateRoundInfo() {
            const monthsPassed = currentRound - 1;
            const currentDate = new Date(gameStartDate);
            currentDate.setMonth(currentDate.getMonth() + monthsPassed);

            const options = { year: 'numeric', month: 'long', day: 'numeric' };
            const formattedDate = currentDate.toLocaleDateString('en-US', options);

            roundInfoEl.innerHTML = `Round: ${currentRound} (${formattedDate})`;
        }

        /**
         * Placeholder function to update game time display.
         */
        function updateGameTimer() {
            const elapsedTime = Date.now() - gameStartTime; // milliseconds
            const totalSeconds = Math.floor(elapsedTime / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;

            const formatTime = num => num.toString().padStart(2, '0');

            gameTimerEl.innerHTML = `Time: ${formatTime(hours)}:${formatTime(minutes)}:${formatTime(seconds)}`;
        }

        /**
         * Placeholder function to update power order display.
         * @param {number} activeIndex - The index of the power whose turn it currently is.
         */
        function updatePowerOrder(activeIndex) {
            powerOrderEl.innerHTML = ''; // Clear existing flags

            powersOrder.forEach((power, index) => {
                const flagDiv = document.createElement('div');
                flagDiv.classList.add('power-flag');
                flagDiv.style.backgroundImage = `url('flags/${power}.png')`;
                if (index === activeIndex) {
                    flagDiv.classList.add('current-turn');
                }
                powerOrderEl.appendChild(flagDiv);
            });
        }

        /**
         * Placeholder function to update phase display.
         * @param {number} activeIndex - The index of the current phase.
         */
        function updatePhaseDisplay(activeIndex) {
            phaseDisplayEl.innerHTML = ''; // Clear existing content

            const phaseNameDiv = document.createElement('div');
            phaseNameDiv.classList.add('phase-name');
            phaseNameDiv.textContent = phaseNames[activeIndex];
            phaseDisplayEl.appendChild(phaseNameDiv);

            const phaseDotsDiv = document.createElement('div');
            phaseDotsDiv.classList.add('phase-dots');

            phaseNames.forEach((_, index) => {
                const dot = document.createElement('div');
                dot.classList.add('phase-dot');
                if (index === activeIndex) {
                    dot.classList.add('active');
                }
                phaseDotsDiv.appendChild(dot);
            });
            phaseDisplayEl.appendChild(phaseDotsDiv);
        }

        /**
         * Placeholder function to update victory cities display.
         * @param {number} axisVC - Number of victory cities controlled by Axis.
         * @param {number} alliedVC - Number of victory cities controlled by Allies.
         */
        function updateVictoryCitiesDisplay(axisVC, alliedVC) {
            const totalVC = 19;
            const axisPercentage = (axisVC / totalVC) * 100;
            const alliedPercentage = (alliedVC / totalVC) * 100;

            victoryCitiesDisplayEl.innerHTML = `
                <div class="vc-count">VCs: ${axisVC} (Axis) - ${alliedVC} (Allies)</div>
                <div class="vc-bar-container">
                    <div class="vc-bar axis" style="width: ${axisPercentage}%;"></div>
                    <div class="vc-bar allies" style="width: ${alliedPercentage}%;"></div>
                </div>
            `;
        }

        /**
         * Calculates and updates the IPC display bar based on territories held by each power.
         * It will only display IPCs for major powers.
         */
        function updateIpcDisplayBar() {
            const ipcDisplayBar = document.getElementById('ipcDisplayBar');
            if (!ipcDisplayBar) return;

            // Define the list of major powers to display in the IPC bar
            const majorPowers = ['US', 'UK', 'USSR', 'Germany', 'Italy', 'Japan', 'China', 'Commonwealth', 'France'];

            // Clear the bar before adding new elements
            ipcDisplayBar.innerHTML = '';

            // Loop through the list of major powers
            majorPowers.forEach(power => {
                // Ensure the power exists in the territoriesByCountry object
                if (territoriesByCountry.hasOwnProperty(power)) {
                    const territories = territoriesByCountry[power] || [];
                    let totalIpcs = 0;
                    
                    territories.forEach(territoryName => {
                        const territory = territoryData[territoryName];
                        if (territory && territory.ipc) {
                            totalIpcs += territory.ipc;
                        }
                    });

                    // Create the IPC square element
                    const ipcSquare = document.createElement('div');
                    ipcSquare.classList.add('ipc-square');
                    ipcSquare.style.width = '75px'; 
                    ipcSquare.style.height = '65px'; 
                    ipcSquare.style.backgroundImage = `url('flags/${power}.png')`;
                    ipcSquare.style.backgroundSize = '80% 80%';
                    ipcSquare.style.backgroundPosition = 'center 15%';
                    ipcSquare.style.backgroundRepeat = 'no-repeat';

                    // Create the IPC number overlay
                    const ipcNumberDiv = document.createElement('div');
                    ipcNumberDiv.classList.add('ipc-number');
                    ipcNumberDiv.textContent = totalIpcs;
                    ipcSquare.appendChild(ipcNumberDiv);

                    ipcDisplayBar.appendChild(ipcSquare);
                }
            });
        }

        /**
         * Fetches neutral powers data and draws a draggable, circular flag at the center of each territory.
         * @param {SVGElement} svgElement - The root SVG element to draw on.
         */
        /**
         * Draws flags for neutral territories at fixed coordinates.
         * @param {SVGElement} svgElement - The root SVG element to draw on.
         */
        async function drawNeutralFlags(svgElement) {
            const FLAG_WIDTH = 21;
            const FLAG_HEIGHT = 14;

            try {
                const response = await fetch('neutral-flags.json');
                if (!response.ok) throw new Error('Failed to fetch neutral-flags.json');
                const neutralFlagsData = await response.json();

                const unitLayer = svgElement.querySelector('#unit-layer');
                if (!unitLayer) {
                    console.error("Could not find '#unit-layer' to append flags to.");
                    return;
                }
                
                // Iterate through the JSON data for each power
                for (const power in neutralFlagsData) {
                    neutralFlagsData[power].forEach(flagData => {
                        const { territory, x, y } = flagData;

                        const flagGroup = svgElement.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'g');
                        flagGroup.setAttribute('class', 'neutral-flag-group');
                        flagGroup.setAttribute('data-power-name', power);
                        flagGroup.setAttribute('data-territory-name', territory);
                        // Use the provided x and y coordinates directly
                        flagGroup.setAttribute('transform', `translate(${x - FLAG_WIDTH / 2}, ${y - FLAG_HEIGHT / 2})`);

                        // Flag Image
                        const flagImage = svgElement.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'image');
                        flagImage.setAttribute('href', `flags/${power}.png`);
                        flagImage.setAttribute('x', 0);
                        flagImage.setAttribute('y', 0);
                        flagImage.setAttribute('width', FLAG_WIDTH);
                        flagImage.setAttribute('height', FLAG_HEIGHT);

                        // Rectangular Frame
                        const frameRect = svgElement.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        frameRect.setAttribute('class', 'neutral-flag-rect-frame');
                        frameRect.setAttribute('x', 0);
                        frameRect.setAttribute('y', 0);
                        frameRect.setAttribute('width', FLAG_WIDTH);
                        frameRect.setAttribute('height', FLAG_HEIGHT);

                        flagGroup.appendChild(flagImage);
                        flagGroup.appendChild(frameRect);

                        unitLayer.appendChild(flagGroup);
                    });
                }
            } catch (error) {
                console.error("Error drawing neutral flags:", error);
            }
        }

        // Global variables for map data, populated in loadAndStyleSvg
        let smallIslandsMap = new Set();
        let territoryAdjacencies = {};
        let validDropZones = []; // Array of { name: string, pathElement: SVGPathElement, bbox: DOMRect }


        // Add these new global variables
        let otherSetupData = null; // To store the loaded other-setup.json data


        async function applyTerritoryColors(setupName = "setup 1940") {
            try {
                const territoriesByPowerResponse = await fetch('territories-by-power.json');
                if (!territoriesByPowerResponse.ok) {
                    throw new Error(`HTTP error! status: ${territoriesByPowerResponse.status} for territories-by-power.json`);
                }
                const territoriesByPowerData = await territoriesByPowerResponse.json();
                const setupData = territoriesByPowerData[setupName];

                if (!setupData) {
                    console.warn(`Setup '${setupName}' not found in territories-by-power.json`);
                    return;
                }

                // Fetch and parse the neutral powers data
                const neutralPowersResponse = await fetch('neutral-powers.json');
                if (!neutralPowersResponse.ok) {
                    throw new Error(`HTTP error! status: ${neutralPowersResponse.status} for neutral-powers.json`);
                }
                const neutralPowersData = await neutralPowersResponse.json();

                // Flatten the neutral powers data into a simple map for easy lookup
                const neutralTerritoriesMap = {};
                for (const [powerType, territories] of Object.entries(neutralPowersData)) {
                    territories.forEach(item => {
                        if (typeof item === 'string') {
                            neutralTerritoriesMap[item] = powerType;
                        } else if (typeof item === 'object') {
                            // Handle objects like {"Netherlands": ["Suriname", ...]}
                            for (const subPower in item) {
                                item[subPower].forEach(subTerritory => {
                                    neutralTerritoriesMap[subTerritory] = powerType;
                                });
                            }
                        }
                    });
                }

                const svgDoc = currentSvgElement; // Use the globally available SVG element

                // First, apply colors based on territories-by-power.json
                for (const power in setupData) {
                    if (powerColors[power]) {
                        const territories = setupData[power].territories;
                        territories.forEach(territoryName => {
                            const pathElement = svgDoc.querySelector(`[data-name="${territoryName}"]`);
                            if (pathElement) {
                                pathElement.style.fill = powerColors[power];
                                pathElement.setAttribute('data-power', power); // Ensure data-power is set
                            } else {
                                console.warn(`SVG element for territory '${territoryName}' not found.`);
                            }
                        });
                    } else {
                        console.warn(`No color defined for power: ${power}`);
                    }
                }

                // Then, override neutral territory colors based on neutral-powers.json
                for (const territoryName in neutralTerritoriesMap) {
                    const pathElement = svgDoc.querySelector(`[data-name="${territoryName}"]`);
                    if (pathElement) {
                        const specificNeutralType = neutralTerritoriesMap[territoryName];
                        if (powerColors[specificNeutralType]) {
                            pathElement.style.fill = powerColors[specificNeutralType];
                            pathElement.setAttribute('data-power', specificNeutralType); // Update data-power attribute
                        }
                    }
                }

            } catch (error) {
                console.error('Error loading or applying territory colors:', error);
                alert('Error loading territory colors. Please check your JSON files and console for details.');
            }
        }

        /**
         * Determines the appropriate size for a unit's image based on its type and power.
         * @param {string} unitType - The type of the unit (e.g., 'INF', 'BTS').
         * @param {string} [power=''] - The controlling power of the unit.
         * @returns {number} The size of the unit image in SVG units.
         */
        function getUnitSize(unitType, power = '') {
            if (power === 'Neutral' && !SEA_UNIT_TYPES.includes(unitType)) {
                return NEUTRAL_LAND_UNIT_SIZE;
            }
            switch (unitType) {
                case "Major Industrial Complex":
                    return MAJOR_IC_SIZE;
                case "Minor Industrial Complex":
                    return MINOR_IC_SIZE;
                case "Air Base":
                    return AIR_BASE_SIZE;
                case "Naval Base":
                    return NAVAL_BASE_SIZE;
                default:
                    if (SEA_UNIT_TYPES.includes(unitType)) {
                        return SEA_UNIT_TYPE_SIZES[unitType] || LAND_UNIT_SIZE;
                    }
                    return LAND_UNIT_SIZE;
            }
        }

        /**
         * Creates a detailed railroad track SVG group with ties and two rails.
         * @param {Array<object>} coordinates - Array of {x, y} points.
         * @returns {SVGElement} An SVG <g> element containing the complete track.
         */
        function createRailroadTrack(coordinates) {
            const trackWidth = 6; // Distance between the two rails
            const tieLength = 10;  // Total length of a railroad tie
            const tieSpacing = 4; // Distance between ties
            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');

            // Layer 1: Ties (drawn first to be on the bottom)
            for (let i = 0; i < coordinates.length - 1; i++) {
                const p1 = coordinates[i];
                const p2 = coordinates[i + 1];

                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const segmentLength = Math.sqrt(dx * dx + dy * dy);
                if (segmentLength === 0) continue;

                const nx = dx / segmentLength; // Normalized vector of the segment
                const ny = dy / segmentLength;
                const px = -ny; // Normalized perpendicular vector
                const py = nx;

                // Place ties along the segment at regular intervals
                const numTies = Math.floor(segmentLength / tieSpacing);
                for (let j = 0; j <= numTies; j++) {
                    const distAlongSegment = j * tieSpacing;
                    const tieCenterX = p1.x + nx * distAlongSegment;
                    const tieCenterY = p1.y + ny * distAlongSegment;

                    const tie = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    tie.setAttribute('x1', tieCenterX - px * tieLength / 2);
                    tie.setAttribute('y1', tieCenterY - py * tieLength / 2);
                    tie.setAttribute('x2', tieCenterX + px * tieLength / 2);
                    tie.setAttribute('y2', tieCenterY + py * tieLength / 2);
                    tie.setAttribute('stroke', '#000000');
                    tie.setAttribute('stroke-width', '1.5');
                    tie.setAttribute('stroke-linecap', 'round');
                    group.appendChild(tie);
                }
            }

            // Layer 2: The two rails
            const rail1Points = [];
            const rail2Points = [];

            for (let i = 0; i < coordinates.length; i++) {
                const p_curr = coordinates[i];
                const p_prev = i > 0 ? coordinates[i - 1] : p_curr;
                const p_next = i < coordinates.length - 1 ? coordinates[i + 1] : p_curr;

                const dx1 = p_curr.x - p_prev.x, dy1 = p_curr.y - p_prev.y;
                const len1 = Math.sqrt(dx1*dx1 + dy1*dy1);
                const perp1x = len1 > 0 ? -dy1 / len1 : 0;
                const perp1y = len1 > 0 ? dx1 / len1 : 0;
                
                const dx2 = p_next.x - p_curr.x, dy2 = p_next.y - p_curr.y;
                const len2 = Math.sqrt(dx2*dx2 + dy2*dy2);
                const perp2x = len2 > 0 ? -dy2 / len2 : 0;
                const perp2y = len2 > 0 ? dx2 / len2 : 0;
                
                let perpx = (perp1x + perp2x) / 2, perpy = (perp1y + perp2y) / 2;
                const mag = Math.sqrt(perpx*perpx + perpy*perpy);
                if (mag > 0) { perpx /= mag; perpy /= mag; }

                rail1Points.push(`${p_curr.x + perpx * trackWidth / 2},${p_curr.y + perpy * trackWidth / 2}`);
                rail2Points.push(`${p_curr.x - perpx * trackWidth / 2},${p_curr.y - perpy * trackWidth / 2}`);
            }

            const rail1 = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
            rail1.setAttribute('points', rail1Points.join(' '));
            rail1.setAttribute('fill', 'none');
            rail1.setAttribute('stroke', '#000000');
            rail1.setAttribute('stroke-width', '1');
            rail1.setAttribute('stroke-linejoin', 'round');
            group.appendChild(rail1);

            const rail2 = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
            rail2.setAttribute('points', rail2Points.join(' '));
            rail2.setAttribute('fill', 'none');
            rail2.setAttribute('stroke', '#000000');
            rail2.setAttribute('stroke-width', '1');
            rail2.setAttribute('stroke-linejoin', 'round');
            group.appendChild(rail2);

            return group;
        }

        /**
         * Draws infrastructure like railways and roads on the SVG map.
         * @param {SVGElement} svgElement - The SVG root element.
         * @param {Array} infrastructureData - The data array from other-setup.json.
         */
        function drawInfrastructure(svgElement, infrastructureData) {
            const infrastructureItems = infrastructureData.filter(item => item.type === 'railway' || item.type === 'road');

            // Find the first element that likely represents a territory label or IPC number.
            // This assumes your labels/IPCs are rendered as <text> elements or are within a group
            // that contains a <text> element early in the SVG's rendering order.
            const firstLabelOrIpcElement = currentSvgElement.querySelector('text');

            // Iterate through your infrastructure data and draw each railway and road
            infrastructureData.forEach(item => {
                if (item.type === 'railway') {
                    const railwayGroup = createRailroadTrack(item.coordinates);
                    // Insert the railway group before the first label/IPC element, or append if none found.
                    if (firstLabelOrIpcElement) {
                        currentSvgElement.insertBefore(railwayGroup, firstLabelOrIpcElement);
                    } else {
                        currentSvgElement.appendChild(railwayGroup); // Fallback: put on top if no text found
                    }
                } else if (item.type === 'road') {
                    // Assuming createRoadPath function exists based on previous context.
                    // Replace with your actual road drawing logic if different.
                    const roadOutline = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    roadOutline.setAttribute('d', `M${item.coordinates.map(p => `${p.x},${p.y}`).join('L')}`);
                    roadOutline.setAttribute('stroke', 'black'); // You can adjust this color as desired
                    roadOutline.setAttribute('stroke-width', '6'); // Increased from 5 for prominence
                    roadOutline.setAttribute('fill', 'none');

                    const roadLine = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    roadLine.setAttribute('d', `M${item.coordinates.map(p => `${p.x},${p.y}`).join('L')}`);
                    roadLine.setAttribute('stroke', '#5C3D2E'); // Darker brown, adjust as desired
                    roadLine.setAttribute('stroke-width', '4'); // Increased from 3 for prominence
                    roadLine.setAttribute('fill', 'none');

                    // Insert the road elements before the first label/IPC element, or append if none found.
                    if (firstLabelOrIpcElement) {
                        currentSvgElement.insertBefore(roadOutline, firstLabelOrIpcElement);
                        currentSvgElement.insertBefore(roadLine, firstLabelOrIpcElement);
                    } else {
                        currentSvgElement.appendChild(roadOutline);
                        currentSvgElement.appendChild(roadLine);
                    }
                }
            });
        }

        /**
         * Draws "CONVOY" and "SHIPYARD" labels using fixed positions from a JSON file.
         * @param {SVGElement} labelsGroup - The SVG <g> element to which labels will be appended.
         * @param {object} seazoneLabelsData - The parsed data from seazone-labels.json.
         */
        function drawConvoyAndShipyardLabels(labelsGroup, seazoneLabelsData) {
            if (!seazoneLabelsData) {
                console.warn("Sea zone labels data not provided.");
                return;
            }

            const createLabel = (text, x, y) => {
                const textEl = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                textEl.setAttribute('x', x);
                textEl.setAttribute('y', y);
                textEl.setAttribute('text-anchor', 'middle');
                textEl.setAttribute('dominant-baseline', 'middle');
                textEl.setAttribute('fill', '#1AA3BF'); // Light Blue
                textEl.setAttribute('font-weight', 'bold');
                textEl.setAttribute('font-size', '14'); // Adjust size as needed
                textEl.textContent = text;
                
                // Append to the dedicated labels group to control layering
                labelsGroup.appendChild(textEl);
            };

            // Create CONVOY labels
            if (seazoneLabelsData.convoys) {
                seazoneLabelsData.convoys.forEach(convoy => {
                    createLabel("CONVOY", convoy.x, convoy.y);
                });
            }

            // Create SHIPYARD labels
            if (seazoneLabelsData.shipyards) {
                seazoneLabelsData.shipyards.forEach(shipyard => {
                    createLabel("SHIPYARD", shipyard.x, shipyard.y);
                });
            }
        }

        // --- UPDATED FUNCTION TO DRAW OTHER LABELS ---
        async function drawOtherLabels() {
            const svg = currentSvgElement;

            // --- Load Oil & Resources from oil-resources.json ---
            try {
                const response = await fetch('oil-resources.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} for oil-resources.json`);
                }
                const data = await response.json();

                // Find the "Oil" object in the array and get its coordinates
                const oilCoords = data.find(item => item.Oil)?.Oil;
                if (oilCoords) {
                    oilCoords.forEach(coord => {
                        createImage(svg, 'units/oil.png', coord.x, coord.y, 50);
                    });
                }

                // Find the "Resources" object in the array and get its coordinates
                const resourceCoords = data.find(item => item.Resources)?.Resources;
                if (resourceCoords) {
                    resourceCoords.forEach(coord => {
                        createImage(svg, 'units/resources.png', coord.x, coord.y, 50);
                    });
                }
            } catch (error) {
                console.error("Error loading or processing oil-resources.json:", error);
            }

            // --- Load Victory Cities from other-setup.json (This part remains) ---
            try {
                const response = await fetch('other-setup.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} for other-setup.json`);
                }
                const otherSetupData = await response.json();
                const victoryCitiesData = otherSetupData.find(d => d.type === 'victory city');

                if (victoryCitiesData) {
                    victoryCitiesData.cities.forEach(city => {
                        createVictoryCityIcon(svg, city.x, city.y, 6);
                        createText(svg, city.city, city.x, city.y + 10, 'victory-city-text');
                    });
                }
            } catch (error) {
                console.error("Error loading or processing other-setup.json for victory cities:", error);
            }
        }

        // Helper function to create an image element and append it to the SVG
        function createImage(svg, href, x, y, size) {
            const img = document.createElementNS("http://www.w3.org/2000/svg", "image");
            img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', href);
            img.setAttribute('x', x - size / 2);
            img.setAttribute('y', y - size / 2);
            img.setAttribute('width', size);
            img.setAttribute('height', size);
            img.classList.add('other-label');
            img.setAttribute('data-type', href.includes('oil') ? 'oil' : 'resources');
            svg.appendChild(img);
            return img;
        }

        // Helper function to create the victory city icon (star with inner circle)
        function createVictoryCityIcon(svg, x, y, size) {
            // Create the star (polygon with 5 points)
            const starPoints = calculateStarPoints(x, y, size);
            const star = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
            star.setAttribute('points', starPoints.join(' '));
            star.setAttribute('fill', 'white');
            star.setAttribute('stroke', 'black');
            star.setAttribute('stroke-width', '1px');
            star.classList.add('other-label');
            svg.appendChild(star);

            // Create the inner circle
            const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            circle.setAttribute('cx', x);
            circle.setAttribute('cy', y);
            circle.setAttribute('r', size * 0.3); // A smaller circle in the middle
            circle.setAttribute('fill', 'black');
            circle.classList.add('other-label');
            svg.appendChild(circle);
        }

        // Helper function to calculate the points for a 5-point star
        // No changes here, this function is correct.
        function calculateStarPoints(cx, cy, outerRadius) {
            const innerRadius = outerRadius * 0.4;
            const points = [];
            const angle = Math.PI / 2; // Start at the top point

            for (let i = 0; i < 5; i++) {
                // Outer point
                points.push(
                    cx + outerRadius * Math.cos(angle + i * 2 * Math.PI / 5),
                    cy + outerRadius * Math.sin(angle + i * 2 * Math.PI / 5)
                );
                // Inner point
                points.push(
                    cx + innerRadius * Math.cos(angle + (i * 2 * Math.PI / 5) + (Math.PI / 5)),
                    cy + innerRadius * Math.sin(angle + (i * 2 * Math.PI / 5) + (Math.PI / 5))
                );
            }
            return points;
        }

        // Helper function to create text elements
        function createText(svg, textContent, x, y, className) {
            const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
            text.setAttribute('x', x);
            text.setAttribute('y', y);
            text.setAttribute('text-anchor', 'middle');
            text.textContent = textContent;
            text.classList.add(className);
            svg.appendChild(text);
        }

        // Helper function to get the centroid of any SVG element
        function getElementCentroid(element) {
            if (!element) {
                return null;
            }

            try {
                const bbox = element.getBBox();
                return {
                    x: bbox.x + bbox.width / 2,
                    y: bbox.y + bbox.height / 2
                };
            } catch (e) {
                console.error("Could not get bounding box for element:", element, e);
                return null;
            }
        }

        /**
         * Checks if a territory has an Air Base in the 1940 setup.
         * @param {string} territoryName - The name of the territory to check.
         * @returns {boolean} True if a 1940-compatible Air Base exists.
         */
        function has1940AirBase(territoryName) {
            if (!setupData) return false;
            for (const power of setupData) {
                const territory = power.territories.find(t => t.name === territoryName);
                if (territory && territory.units) {
                    // An 'Air Base' key (no year) or 'Air Base 1940' counts. 'Air Base 1942' is ignored.
                    if (territory.units['Air Base'] || territory.units['Air Base 1940']) {
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Checks if a territory has a Naval Base in the 1940 setup.
         * @param {string} territoryName - The name of the territory to check.
         * @returns {boolean} True if a 1940-compatible Naval Base exists.
         */
        function has1940NavalBase(territoryName) {
            if (!setupData) return false;
            for (const power of setupData) {
                const territory = power.territories.find(t => t.name === territoryName);
                if (territory && territory.units) {
                    // A 'Naval Base' key (no year) or 'Naval Base 1940' counts. 'Naval Base 1942' is ignored.
                    if (territory.units['Naval Base'] || territory.units['Naval Base 1940']) {
                        return true;
                    }
                }
            }
            return false;
        }


        /**
         * Darkens a hex color by a given percentage.
         * @param {string} hex - The hex color string (e.g., "#RRGGBB").
         * @param {number} percent - The percentage to darken (e.g., 0.2 for 20% darker, -0.2 for 20% lighter).
         * @returns {string} The darkened hex color string.
         */
        function darkenColor(hex, percent) {
            let f = parseInt(hex.slice(1), 16),
                p = Math.abs(percent),
                R = f >> 16, G = (f >> 8) & 0x00FF, B = f & 0x0000FF;

            let newR, newG, newB;

            if (percent > 0) { // Darken (move towards 0)
                newR = Math.round(R * (1 - p));
                newG = Math.round(G * (1 - p));
                newB = Math.round(B * (1 - p));
            } else { // Lighten (move towards 255)
                newR = Math.round(R + (255 - R) * p);
                newG = Math.round(G + (255 - G) * p);
                newB = Math.round(B + (255 - B) * p);
            }

            // Ensure values stay within 0-255 range
            const finalR = Math.max(0, Math.min(255, newR));
            const finalG = Math.max(0, Math.min(255, newG));
            const finalB = Math.max(0, Math.min(255, newB));

            return "#" + ((1 << 24) + (finalR << 16) + (finalG << 8) + finalB).toString(16).slice(1);
        }

        /**
         * Estimates the width of a text string in SVG coordinates.
         * This is a simple heuristic and might not be perfectly accurate for all fonts/sizes.
         * @param {string} text - The text content.
         * @param {number} fontSize - The font size.
         * @returns {number} The estimated width.
         */
        function estimateTextWidth(text, fontSize) {
            return text.length * (fontSize * 0.6); // Adjust 0.6 as needed for your font
        }

        /**
         * Checks if two rectangles are colliding.
         * @param {object} rect1 - {x, y, width, height}
         * @param {object} rect2 - {x, y, width, height}
         * @returns {boolean} True if they are colliding, false otherwise.
         */
        function isColliding(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

                /**
         * Checks if a rectangle (unit's bounding box) is sufficiently within an SVG path element.
         * This is a more robust check than just using getBBox().
         * It checks multiple sample points within the rectangle.
         * @param {SVGPathElement|SVGPolygonElement} pathElement - The SVG path or polygon element.
         * @param {object} rect - {x, y, width, height}
         * @returns {boolean} True if a significant portion of the rect is within the path.
         */
        function isRectInPath(pathElement, rect) {
            if (!pathElement || typeof pathElement.isPointInFill !== 'function') {
                return false; // Not a valid path element for this check
            }

            // Define sample points (e.g., corners and center)
            const points = [
                { x: rect.x, y: rect.y }, // Top-left
                { x: rect.x + rect.width, y: rect.y }, // Top-right
                { x: rect.x, y: rect.y + rect.height }, // Bottom-left
                { x: rect.x + rect.width, y: rect.y + rect.height }, // Bottom-right
                { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 } // Center
            ];

            let pointsInPath = 0;
            const svgPoint = currentSvgElement.createSVGPoint();

            for (const p of points) {
                svgPoint.x = p.x;
                svgPoint.y = p.y;
                if (pathElement.isPointInFill(svgPoint)) {
                    pointsInPath++;
                }
            }

            // Consider it "in path" if at least 3 of 5 points are within the path, or all corners.
            return pointsInPath >= 3 || (pathElement.isPointInFill(points[0]) && pathElement.isPointInFill(points[1]) && pathElement.isPointInFill(points[2]) && pathElement.isPointInFill(points[3]));
        }



        /**
         * Creates and appends an SVG text element.
         * @param {SVGElement} svgElement - The SVG root element.
         * @param {string} textContent - The text to display.
         * @param {number} x - X coordinate.
         * @param {number} y - Y coordinate.
         * @param {number} fontSize - Font size.
         * @param {string} type - 'name' or 'ipcs' or 'word'.
         * @param {string} territoryName - The original territory name.
         * @param {string} [wordIndex] - Index for individual words if split.
         * @returns {SVGTextElement} The created text element.
         */
        function createSvgText(svgElement, textContent, x, y, fontSize, type, territoryName, wordIndex = null) {
            const textEl = svgElement.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'text');
            textEl.setAttribute('x', x);
            textEl.setAttribute('y', y);
            textEl.setAttribute('text-anchor', 'middle');
            textEl.setAttribute('dominant-baseline', 'middle');
            textEl.setAttribute('fill', 'white');
            textEl.setAttribute('stroke', 'black');
            textEl.setAttribute('stroke-width', (type === 'ipcs' || type === 'word') ? '0.4' : '0.3');
            textEl.setAttribute('font-size', fontSize);
            textEl.setAttribute('font-weight', 'bold');
            textEl.setAttribute('data-name', territoryName);
            textEl.setAttribute('data-type', type);
            if (wordIndex !== null) {
                textEl.setAttribute('data-word-index', wordIndex);
            }
            textEl.textContent = textContent;
            svgElement.appendChild(textEl);
            return textEl;
        }

        /**
         * Updates the content and layout of an SVG text element, handling multi-line text.
         * @param {SVGTextElement} textEl - The SVG text element to update.
         * @param {string} originalText - The full original text content.
         * @param {number} fontSize - The font size to apply.
         * @param {number} xPos - The x position for the text.
         */
        function updateTextElementContent(textEl, originalText, fontSize, xPos) {
            // Clear existing tspans
            while (textEl.firstChild) {
                textEl.removeChild(textEl.firstChild);
            }

            const words = originalText.split(' ');
            let lines = [];
            let currentLine = '';
            const maxTextWidth = 10000; // Arbitrarily large for this context, as bounding box is for the whole territory
            const lineHeight = fontSize * 1.2;

            // Simple text wrapping logic
            if (estimateTextWidth(originalText, fontSize) > maxTextWidth) {
                for (let i = 0; i < words.length; i++) {
                    const word = words[i];
                    const testLine = currentLine === '' ? word : currentLine + ' ' + word;

                    if (estimateTextWidth(testLine, fontSize) > maxTextWidth && currentLine !== '') {
                        lines.push(currentLine);
                        currentLine = word;
                    } else {
                        currentLine = testLine;
                    }
                }
                if (currentLine !== '') {
                    lines.push(currentLine);
                }
            } else {
                lines.push(originalText); // Fits on one line
            }

            // Adjust the initial Y position to vertically center multi-line text
            const initialY = parseFloat(textEl.getAttribute('y'));
            const newInitialY = initialY - (lines.length - 1) * lineHeight / 2;
            textEl.setAttribute('y', newInitialY); // Set for the <text> element

            lines.forEach((line, index) => {
                const tspan = textEl.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                tspan.setAttribute('x', xPos); // Use the provided X for all tspans
                tspan.setAttribute('dy', index === 0 ? 0 : lineHeight);
                tspan.textContent = line;
                textEl.appendChild(tspan);
            });
        }


        /**
         * Adds territory names and IPC values to the SVG based on loaded settings.
         * @param {SVGElement} svgElement - The injected SVG element.
         * @param {object} loadedSettings - Settings loaded from labels.json.
         * @param {object} territoryIpcs - IPC values for each territory from map.svg.
         */
        async function addTerritoryLabels(svgElement, loadedSettings, territoryIpcs) {
            // Clear existing text elements before re-rendering
            svgElement.querySelectorAll('.territory-label, .ipcs-token').forEach(el => el.remove());

            for (const name in loadedSettings) {
                const settings = loadedSettings[name];

                // Render IPCs
                const ipcs = territoryIpcs[name];
                const showIpcs = ipcs !== '0' && ipcs !== null && ipcs !== undefined && ipcs !== '';

                if (showIpcs && settings.ipcsX !== undefined && settings.ipcsY !== undefined && settings.ipcsFontSize !== undefined) {
                    const ipcsCircle = svgElement.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    ipcsCircle.setAttribute('cx', settings.ipcsX);
                    ipcsCircle.setAttribute('cy', settings.ipcsY);
                    ipcsCircle.setAttribute('r', settings.ipcsFontSize * 0.75); // Radius based on font size
                    ipcsCircle.setAttribute('fill', 'rgba(0,0,0,0.6)');
                    ipcsCircle.setAttribute('stroke', 'white');
                    ipcsCircle.setAttribute('stroke-width', '0.5');
                    ipcsCircle.classList.add('ipcs-token');
                    svgElement.appendChild(ipcsCircle);

                    createSvgText(
                        svgElement,
                        ipcs,
                        settings.ipcsX,
                        settings.ipcsY,
                        settings.ipcsFontSize,
                        'ipcs',
                        name
                    ).classList.add('ipcs-token');
                }

                // Render Name (either as one block or split words)
                if (settings.isSplit && settings.words && settings.words.length > 0) {
                    // Render individual words
                    settings.words.forEach((wordSetting, index) => {
                        createSvgText(
                            svgElement,
                            wordSetting.text,
                            wordSetting.x,
                            wordSetting.y,
                            wordSetting.fontSize,
                            'word',
                            name,
                            index
                        ).classList.add('territory-label');
                    });
                } else if (settings.x !== undefined && settings.x !== undefined && settings.fontSize !== undefined) {
                    // Render as a single text block (potentially multi-line)
                    const nameTextElement = createSvgText(
                        svgElement,
                        settings.originalText,
                        settings.x,
                        settings.y,
                        settings.fontSize,
                        'name',
                        name
                    );
                    nameTextElement.classList.add('territory-label');
                    // Re-apply text wrapping
                    updateTextElementContent(nameTextElement, settings.originalText, settings.fontSize, settings.x);
                }
            }
        }

        /**
         * Generates SVG color filters for each power color and appends them to the SVG's defs.
         * Creates two filters per power: one for land/air units (darkened) and one for sea units (original color).
         * Filters convert black images to the specified power color.
         * This version is adapted from the debugger.html, with a modification to skip
         * recoloring for 'Neutral' power units, leaving them their original image color.
         * @param {SVGElement} svgElement - The SVG root element.
         */
        function generateColorFilters(svgElement) {
            let defs = svgElement.querySelector('defs');
            if (!defs) {
                defs = svgElement.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'defs');
                svgElement.insertBefore(defs, svgElement.firstChild);
            }

            // Remove existing unit filters to prevent duplicates on reload
            defs.querySelectorAll('[id^="colorize-"]').forEach(filter => filter.remove());

            const outlineColor = 'black';
            const outlineBlur = 3;

            for (const powerName in powerColors) {
                // Skip generating filters for Neutral power to keep units in their original color
                if (powerName === 'Neutral') {
                    continue;
                }

                const baseColor = powerColors[powerName];
                // Both land/air and sea unit images will now use the base color, not darkened
                const unitImageColor = baseColor;

                // Helper to create a filter
                const createFilter = (id, color) => {
                    let filter = svgElement.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'filter');
                    filter.setAttribute('id', id);
                    // Extend filter area to accommodate blur/outline
                    filter.setAttribute('x', '-50%');
                    filter.setAttribute('y', '-50%');
                    filter.setAttribute('width', '200%');
                    filter.setAttribute('height', '200%');

                    // 1. Create the outline (black, blurred, from SourceAlpha)
                    let feGaussianBlur = svgElement.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'feGaussianBlur');
                    feGaussianBlur.setAttribute('in', 'SourceAlpha');
                    feGaussianBlur.setAttribute('stdDeviation', outlineBlur);
                    feGaussianBlur.setAttribute('result', 'blur');

                    let feFloodOutline = svgElement.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'feFlood');
                    feFloodOutline.setAttribute('flood-color', outlineColor);
                    feFloodOutline.setAttribute('result', 'outlineColorFlood');

                    let feCompositeOutline = svgElement.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'feComposite');
                    feCompositeOutline.setAttribute('in', 'outlineColorFlood');
                    feCompositeOutline.setAttribute('in2', 'blur');
                    feCompositeOutline.setAttribute('operator', 'in'); // "in" clips flood to blurred shape
                    feCompositeOutline.setAttribute('result', 'outline');

                    // 2. Recolor the original unit image (from SourceGraphic)
                    // This method takes the SourceGraphic's alpha and floods it with the desired color.
                    let feFloodColoredUnit = svgElement.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'feFlood');
                    feFloodColoredUnit.setAttribute('flood-color', color);
                    feFloodColoredUnit.setAttribute('result', 'unitColorFlood');

                    let feCompositeColoredUnit = svgElement.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'feComposite');
                    feCompositeColoredUnit.setAttribute('in', 'unitColorFlood');
                    feCompositeColoredUnit.setAttribute('in2', 'SourceAlpha'); // Use SourceAlpha to cut out the shape
                    feCompositeColoredUnit.setAttribute('operator', 'in');
                    feCompositeColoredUnit.setAttribute('result', 'coloredUnit');

                    // 3. Merge outline and colored unit (outline under colored unit)
                    let feMerge = svgElement.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'feMerge');
                    let feMergeNode1 = svgElement.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'feMergeNode');
                    feMergeNode1.setAttribute('in', 'outline'); // Outline goes first (bottom layer)
                    let feMergeNode2 = svgElement.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'feMergeNode');
                    feMergeNode2.setAttribute('in', 'coloredUnit'); // Colored unit goes second (top layer)
                    feMerge.appendChild(feMergeNode1);
                    feMerge.appendChild(feMergeNode2);
                    feMerge.setAttribute('result', 'output');

                    filter.appendChild(feGaussianBlur);
                    filter.appendChild(feFloodOutline);
                    filter.appendChild(feCompositeOutline);
                    filter.appendChild(feFloodColoredUnit);
                    filter.appendChild(feCompositeColoredUnit);
                    filter.appendChild(feMerge);

                    return filter;
                };

                // Both land and sea units will now use the `unitImageColor` (which is `baseColor`)
                defs.appendChild(createFilter(`colorize-${powerName}-land`, unitImageColor));
                defs.appendChild(createFilter(`colorize-${powerName}-sea`, unitImageColor));
            }
        }


        /**
         * Places unit tokens on the map for the 1940 setup.
         * Prioritizes showing all pieces, even if it means slight stacking or overflow for small islands.
         * Non-small islands will prioritize staying within borders.
         * @param {SVGElement} svgElement - The SVG root element.
         * @param {object} setupData - The parsed data from setup.json.
         * @param {object} textSettings - The parsed data from labels.json for avoiding overlaps.
         * @param {Set<string>} smallIslandsMap - A set of territory names identified as small islands.
         * @param {object} territoryAdjacencies - The parsed data from territory-adjacencies.json.
         * @param {object} [initialUnitCoordinatesByTerritory=null] - Optional object of territory names to arrays of {x,y} coordinates to load.
         */
        function placeUnits(svgElement, setupData, textSettings, smallIslandsMap, territoryAdjacencies, initialUnitCoordinatesByTerritory = null, infrastructureCoordinates = null, unitProfileData = [], unitLayerGroup) {

            console.log("placeUnits called. Received infrastructureCoordinates:", infrastructureCoordinates);

            // Clear existing units and reset global data array
            svgElement.querySelectorAll('.unit-stack-group').forEach(el => el.remove());
            placedUnitsData = [];

            const MAX_PLACEMENT_ATTEMPTS = 5000;
            const PLACEMENT_STEP = 5;

            // This array will store the bounding boxes of all placed unit *groups* for collision detection
            const placedUnitRects = [];

            // Helper function to try placement in a given target territory/sea zone
            const tryPlaceInTarget = (targetTerritoryName, unitWidth, unitHeight, targetBounds = null) => {
                const targetPathElement = svgElement.querySelector(`[data-name="${targetTerritoryName}"]`);
                if (!targetPathElement) {
                    console.warn(`Path element not found for territory/sea zone: ${targetTerritoryName}. Cannot place unit.`);
                    return null;
                }
                const targetBBox = targetPathElement.getBBox();

                // Use provided targetBounds if available, otherwise default to targetBBox
                const effectiveTargetBounds = targetBounds || targetBBox;

                if (effectiveTargetBounds.width < unitWidth || effectiveTargetBounds.height < unitHeight) {
                    console.warn(`Effective target bounds for ${targetTerritoryName} (${effectiveTargetBounds.width}x${effectiveTargetBounds.height}) are smaller than unit (${unitWidth}x${unitHeight}). Placing at center.`);
                    const proposedRect = {
                        x: effectiveTargetBounds.x + effectiveTargetBounds.width / 2 - unitWidth / 2,
                        y: effectiveTargetBounds.y + effectiveTargetBounds.height / 2 - unitHeight / 2,
                        width: unitWidth,
                        height: unitHeight
                    };
                    placedUnitRects.push(proposedRect);
                    return {
                        x: proposedRect.x,
                        y: proposedRect.y,
                        targetName: targetTerritoryName
                    };
                }

                const currentOccupiedLabelsRects = [];

                const targetLabelInfo = textSettings[targetTerritoryName];
                if (targetLabelInfo) {
                    if (targetLabelInfo.isSplit && targetLabelInfo.words) {
                        targetLabelInfo.words.forEach(wordSetting => {
                            const wordWidth = estimateTextWidth(wordSetting.text, wordSetting.fontSize);
                            const wordHeight = wordSetting.fontSize * 1.2;
                            currentOccupiedLabelsRects.push({
                                x: wordSetting.x - wordWidth / 2,
                                y: wordSetting.y - wordHeight / 2,
                                width: wordWidth,
                                height: wordHeight
                            });
                        });
                    } else if (targetLabelInfo.x !== undefined && targetLabelInfo.y !== undefined && targetLabelInfo.originalText !== undefined && targetLabelInfo.fontSize !== undefined) {
                        const labelWidth = estimateTextWidth(targetLabelInfo.originalText, targetLabelInfo.fontSize);
                        const numLines = (targetLabelInfo.originalText.split(' ').length > 4 || targetLabelInfo.originalText.includes('\n')) ? (targetLabelInfo.originalText.split(' ').length > 4 ? 2 : 1) : 1;
                        const labelHeight = targetLabelInfo.fontSize * 1.2 * numLines;
                        currentOccupiedLabelsRects.push({
                            x: targetLabelInfo.x - labelWidth / 2,
                            y: targetLabelInfo.y - labelHeight / 2,
                            width: labelWidth,
                            height: labelHeight
                        });
                    }

                    if (targetLabelInfo.ipcsX !== undefined && targetLabelInfo.ipcsY !== undefined && targetLabelInfo.ipcsFontSize !== undefined) {
                        const ipcsRadius = targetLabelInfo.ipcsFontSize * 0.75;
                        currentOccupiedLabelsRects.push({
                            x: targetLabelInfo.ipcsX - ipcsRadius,
                            y: targetLabelInfo.ipcsY - ipcsRadius,
                            width: ipcsRadius * 2,
                            height: ipcsRadius * 2
                        });
                    }
                }

                let spiral_x_offset = 0;
                let spiral_y_offset = 0;
                let spiral_direction = 0;
                let spiral_segment_length = 1;
                let spiral_segment_passed = 0;

                const centerX = effectiveTargetBounds.x + effectiveTargetBounds.width / 2;
                const centerY = effectiveTargetBounds.y + effectiveTargetBounds.height / 2;

                let fallbackSpotFound = null;

                for (let attempt = 0; attempt < MAX_PLACEMENT_ATTEMPTS; attempt++) {
                    let currentX = centerX + spiral_x_offset * PLACEMENT_STEP;
                    let currentY = centerY + spiral_y_offset * PLACEMENT_STEP;

                    const potentialUnitRect = {
                        x: currentX - unitWidth / 2,
                        y: currentY - unitHeight / 2,
                        width: unitWidth,
                        height: unitHeight
                    };

                    // Check if the potential unit rect is within the effective target bounds
                    let isWithinBounds = potentialUnitRect.x >= effectiveTargetBounds.x &&
                                         potentialUnitRect.y >= effectiveTargetBounds.y &&
                                         (potentialUnitRect.x + potentialUnitRect.width) <= (effectiveTargetBounds.x + effectiveTargetBounds.width) &&
                                         (potentialUnitRect.y + potentialUnitRect.height) <= (effectiveTargetBounds.y + effectiveTargetBounds.height);

                    // For territories, also check if it's within the actual path shape
                    if (targetBounds === null) { // Only do this for actual territories, not extended sea zones
                        isWithinBounds = isWithinBounds && isRectInPath(targetPathElement, potentialUnitRect);
                    }


                    let collisionWithLabelsOrUnits = false;
                    for (const rect of currentOccupiedLabelsRects) {
                        if (isColliding(potentialUnitRect, rect)) {
                            collisionWithLabelsOrUnits = true;
                            break;
                        }
                    }
                    if (!collisionWithLabelsOrUnits) {
                         for (const existingUnitRect of placedUnitRects) {
                            if (isColliding(potentialUnitRect, existingUnitRect)) {
                                collisionWithLabelsOrUnits = true;
                                break;
                            }
                        }
                    }

                    if (isWithinBounds && !collisionWithLabelsOrUnits) {
                        placedUnitRects.push(potentialUnitRect);
                        return { x: potentialUnitRect.x, y: potentialUnitRect.y, targetName: targetTerritoryName };
                    } else if (isWithinBounds && !fallbackSpotFound) {
                        fallbackSpotFound = { x: potentialUnitRect.x, y: potentialUnitRect.y, targetName: targetTerritoryName };
                    }

                    spiral_segment_passed++;
                    if (spiral_segment_passed === spiral_segment_length) {
                        spiral_segment_passed = 0;
                        spiral_direction = (spiral_direction + 1) % 4;
                        if (spiral_direction === 0 || spiral_direction === 2) {
                            spiral_segment_length++;
                        }
                    }
                    if (spiral_direction === 0) spiral_x_offset++;
                    else if (spiral_direction === 1) spiral_y_offset++;
                    else if (spiral_direction === 2) spiral_x_offset--;
                    else if (spiral_direction === 3) spiral_y_offset--;
                }

                if (fallbackSpotFound) {
                    placedUnitRects.push(fallbackSpotFound);
                    return fallbackSpotFound;
                }

                console.warn(`Spiral search failed for ${targetTerritoryName}. Placing unit at territory BBox center as last resort.`);
                const finalFallbackRect = {
                    x: centerX - unitWidth / 2,
                    y: centerY - unitHeight / 2,
                    width: unitWidth,
                    height: unitHeight
                };
                placedUnitRects.push(finalFallbackRect);
                return {
                    x: finalFallbackRect.x,
                    y: finalFallbackRect.y,
                    targetName: targetTerritoryName
                };
            };

            const unitInstanceCounters = {}; // For generating unique IDs

            // 1. Aggregate Units from setupData into visual stacks
            const aggregatedUnitStacks = [];
            setupData.forEach(powerEntry => {
                const controllingPowerName = powerEntry.name;
                powerEntry.territories.forEach(territory => {
                    const territoryName = territory.name;

                    if (controllingPowerName === 'Neutral') {
                        // For neutrals, territory.units is an array of individual unit objects.
                        const individualUnitList = territory.units; // This is the array from neutral.json

                        // Check if it's a valid array and iterate over each unit entry.
                        if (Array.isArray(individualUnitList)) {
                            individualUnitList.forEach(unitData => {
                                // unitData is an object like { unitType: "INF", x: 123, y: 456 }
                                aggregatedUnitStacks.push({
                                    territory: territoryName,
                                    unitType: unitData.unitType, // Get the correct unit type from the object
                                    power: controllingPowerName,
                                    initialCount: unitData.count,             // Each entry is a single unit
                                    x: unitData.x,               // Use the x coordinate from the object
                                    y: unitData.y                // Use the y coordinate from the object
                                });
                            });
                        }
                    } else {
                        const unitsInTerritoryByType = {};
                        const infrastructurePresence = {
                            "Industrial Complex": false,
                            "Air Base": false,
                            "Naval Base": false
                        };

                        for (const unitKey in territory.units) {
                            if (unitKey.endsWith("1942")) continue;
                            const unitType = unitKey.replace(/\s1940$/, '');
                            const count = territory.units[unitKey];

                            if (UNIT_IMAGE_MAP[unitType] && count > 0) {
                                if (unitType === "Major Industrial Complex") {
                                    infrastructurePresence["Industrial Complex"] = "Major Industrial Complex";
                                } else if (unitType === "Minor Industrial Complex" && infrastructurePresence["Industrial Complex"] !== "Major Industrial Complex") {
                                    infrastructurePresence["Industrial Complex"] = "Minor Industrial Complex";
                                } else if (unitType === "Air Base") {
                                    infrastructurePresence["Air Base"] = "Air Base";
                                } else if (unitType === "Naval Base") {
                                    infrastructurePresence["Naval Base"] = "Naval Base";
                                } else {
                                    unitsInTerritoryByType[unitType] = (unitsInTerritoryByType[unitType] || 0) + count;
                                }
                            }
                        }

                        if (infrastructurePresence["Industrial Complex"]) {
                            unitsInTerritoryByType[infrastructurePresence["Industrial Complex"]] = 1;
                        }
                        if (infrastructurePresence["Air Base"]) {
                            unitsInTerritoryByType["Air Base"] = 1;
                        }
                        if (infrastructurePresence["Naval Base"]) {
                            unitsInTerritoryByType["Naval Base"] = 1;
                        }

                        for (const unitType in unitsInTerritoryByType) {
                            aggregatedUnitStacks.push({
                                territory: territoryName,
                                unitType: unitType,
                                power: controllingPowerName,
                                initialCount: unitsInTerritoryByType[unitType],
                                x: null,
                                y: null
                            });
                        }
                    }
                });
            });

            // 2. Apply Loaded Coordinates (if provided)
            // Apply loaded coordinates
            const availableCoords = initialUnitCoordinatesByTerritory ? JSON.parse(JSON.stringify(initialUnitCoordinatesByTerritory)) : {};

            aggregatedUnitStacks.forEach(unitStack => {
                const territory = unitStack.territory;

                // Give infrastructure JSON highest priority
                if (SPECIAL_INFRASTRUCTURE_UNITS.includes(unitStack.unitType)) { // Check if it's an infrastructure unit first
                    
                    // ADD THIS LOG
                    console.log(`Processing infrastructure unit: ${unitStack.unitType} in ${territory}.`);

                    if (infrastructureCoordinates && infrastructureCoordinates[territory] && Array.isArray(infrastructureCoordinates[territory])) {
                        const infraUnitCoords = infrastructureCoordinates[territory].find(
                            entry => entry.unitType === unitStack.unitType
                        );

                        if (infraUnitCoords) {
                            unitStack.x = infraUnitCoords.x;
                            unitStack.y = infraUnitCoords.y;
                            
                            // ADD THIS LOG
                            console.log(`SUCCESS: Found and applied coordinates for ${unitStack.unitType} in ${territory}:`, {x: unitStack.x, y: unitStack.y});

                            return; // ✅ Do not allow override by general coordinates
                        } else {
                            // ADD THIS LOG
                            console.warn(`WARN: No specific coordinate entry for unit type "${unitStack.unitType}" found in territory "${territory}" inside infrastructure-coordinates.json. It will be auto-placed.`);
                        }
                    } else {
                        // ADD THIS LOG
                        console.warn(`WARN: No coordinates found for territory "${territory}" in the infrastructureCoordinates object. ${unitStack.unitType} will be auto-placed.`);
                    }
                }
                // Use general unit coordinates only if infrastructure wasn't matched
                if (availableCoords[territory] && availableCoords[territory].length > 0) {
                    const coord = availableCoords[territory].shift();
                    unitStack.x = coord.x;
                    unitStack.y = coord.y;
                }
            });


            // 3. Place Units (Iterate aggregatedUnitStacks)
            // Sort by size for better packing, larger units first
            aggregatedUnitStacks.sort((a, b) => getUnitSize(b.unitType) - getUnitSize(a.unitType));

            aggregatedUnitStacks.forEach(unitStack => {
                const { territory, unitType, power: controllingPowerName, initialCount, x: loadedX, y: loadedY } = unitStack;
                const isCurrentTerritorySmallIsland = smallIslandsMap.has(territory);

                const imageFileName = UNIT_IMAGE_MAP[unitType];
                const unitImageSize = getUnitSize(unitType);

                let filterId = '';
                if (powerColors[controllingPowerName] && controllingPowerName !== 'Neutral') {
                    filterId = `url(#colorize-${controllingPowerName}-${SEA_UNIT_TYPES.includes(unitType) ? 'sea' : 'land'})`;
                } else {
                    filterId = '';
                }

                // Calculate the overall bounding box for this unit stack (image + optional count circle)
                let groupWidth = unitImageSize;
                let groupHeight = unitImageSize;

                // Adjust groupHeight to account for the count circle if present
                if (initialCount > 1 && !SPECIAL_INFRASTRUCTURE_UNITS.includes(unitType)) { // Only for regular units
                    groupHeight = unitImageSize + (UNIT_COUNT_CIRCLE_RADIUS * 2); // Image height + full height of count circle
                    groupWidth = Math.max(groupWidth, (UNIT_COUNT_CIRCLE_RADIUS * 2)); // Ensure group width accommodates count circle
                } else if (SPECIAL_INFRASTRUCTURE_UNITS.includes(unitType)) {
                    // For infrastructure, adjust height to accommodate text label below
                    groupHeight = unitImageSize + SPECIAL_UNIT_TEXT_FONT_SIZE * 1.5; // Image height + text height + some padding
                }


                let foundPlacement = null;

                // Determine the target placement area based on territory type and adjacencies
                let targetPlacementName = territory; // Default to the territory itself
                let effectivePlacementBounds = null; // Will be set for extended sea zones

                if (isCurrentTerritorySmallIsland) {
                    // For small islands, use the entire bounding box of adjacent sea zones
                    const adjacencies = territoryAdjacencies[territory]?.adjacent_to || [];
                    const adjacentSeaZones = adjacencies.filter(adj => !isNaN(Number(adj)));

                    if (adjacentSeaZones.length > 0) {
                        // Aggregate bounding boxes of all adjacent sea zones
                        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                        let allSeaZonesFound = true;
                        adjacentSeaZones.forEach(seaZoneName => {
                            const seaZonePath = svgElement.querySelector(`[data-name="${seaZoneName}"]`);
                            if (seaZonePath) {
                                const bbox = seaZonePath.getBBox();
                                minX = Math.min(minX, bbox.x);
                                minY = Math.min(minY, bbox.y);
                                maxX = Math.max(maxX, bbox.x + bbox.width);
                                maxY = Math.max(maxY, bbox.y + bbox.height);
                            } else {
                                console.warn(`Sea zone path not found for ${seaZoneName}.`);
                                allSeaZonesFound = false;
                            }
                        });

                        if (allSeaZonesFound && minX !== Infinity) {
                            effectivePlacementBounds = {
                                x: minX,
                                y: minY,
                                width: maxX - minX,
                                height: maxY - minY
                            };
                            // We don't change targetPlacementName, but we pass effectivePlacementBounds
                            // to tryPlaceInTarget to ensure placement within the combined sea zone area.
                        }
                    }
                } else {
                    // For non-small islands, if adjacent to a sea zone, extend the placement area
                    const adjacencies = territoryAdjacencies[territory]?.adjacent_to || [];
                    const adjacentSeaZones = adjacencies.filter(adj => !isNaN(Number(adj)));

                    if (adjacentSeaZones.length > 0) {
                        const territoryPath = svgElement.querySelector(`[data-name="${territory}"]`);
                        if (territoryPath) {
                            const territoryBBox = territoryPath.getBBox();
                            let minX = territoryBBox.x, minY = territoryBBox.y, maxX = territoryBBox.x + territoryBBox.width, maxY = territoryBBox.y + territoryBBox.height;

                            adjacentSeaZones.forEach(seaZoneName => {
                                const seaZonePath = svgElement.querySelector(`[data-name="${seaZoneName}"]`);
                                if (seaZonePath) {
                                    const bbox = seaZonePath.getBBox();
                                    minX = Math.min(minX, bbox.x);
                                    minY = Math.min(minY, bbox.y);
                                    maxX = Math.max(maxX, bbox.x + bbox.width);
                                    maxY = Math.max(maxY, bbox.y + bbox.height);
                                }
                            });

                            effectivePlacementBounds = {
                                x: minX,
                                y: minY,
                                width: maxX - minX,
                                height: maxY - minY
                            };
                            // Again, targetPlacementName remains the territory, but placement uses extended bounds
                        }
                    }
                }


                if (loadedX !== null && loadedY !== null) {
                    const proposedRect = {
                        x: loadedX,
                        y: loadedY,
                        width: groupWidth,
                        height: groupHeight
                    };

                    // Trust the loaded coordinates from the JSON file and bypass validation.
                    console.log(`Using pre-defined coordinates for ${unitType} in ${territory}.`);
                    foundPlacement = { x: loadedX, y: loadedY, targetName: territory };
                    placedUnitRects.push(proposedRect); // Add to rects for collision detection with other auto-placed units.
                }

                if (!foundPlacement) {
                    foundPlacement = tryPlaceInTarget(targetPlacementName, groupWidth, groupHeight, effectivePlacementBounds);
                }


                if (foundPlacement) {
                    const unitGroupElement = svgElement.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'g');
                    unitGroupElement.setAttribute('data-original-territory', territory);
                    unitGroupElement.setAttribute('data-unit-type', unitType);
                    unitGroupElement.setAttribute('data-power', controllingPowerName);
                    unitGroupElement.setAttribute('data-count', initialCount); // Store the actual count
                    unitGroupElement.setAttribute('data-placed-in', foundPlacement.targetName); // Initial placement name
                    unitGroupElement.classList.add('unit-stack-group');
                    unitGroupElement.style.cursor = 'grab';
                    unitGroupElement.setAttribute('transform', `translate(${foundPlacement.x}, ${foundPlacement.y})`);
                    unitLayerGroup.appendChild(unitGroupElement);

                    // Find the unit's profile to get its movement capacity
                    const unitProfile = unitProfileData.find(p => p.unit_type === unitType);
                    const movementCapacity = unitProfile ? unitProfile.movement_capacity : 0;

                    // Generate a unique ID for the unit group
                    const idKey = `${controllingPowerName}-${territory}-${unitType}`.replace(/\s+/g, '-');
                    const instance = (unitInstanceCounters[idKey] = (unitInstanceCounters[idKey] || 0) + 1);
                    const uniqueId = `unit-${idKey}-${instance}`;

                    // Set the new ID and data attributes
                    unitGroupElement.setAttribute('id', uniqueId);
                    unitGroupElement.setAttribute('data-has-moved', 'false');
                    unitGroupElement.setAttribute('data-movement-remaining', movementCapacity);

                    // Store this unit's data in the global array
                    placedUnitsData.push({
                        element: unitGroupElement,
                        originalTerritory: territory,
                        placedIn: foundPlacement.targetName, // Store the initial placed-in territory
                        unitType: unitType,
                        power: controllingPowerName,
                        count: initialCount, // Store the actual count
                        x: foundPlacement.x,
                        y: foundPlacement.y
                    });

                    let imageX = (groupWidth - unitImageSize) / 2;
                    let imageY = 0; // Image starts at the top of the group's local coordinates

                    // 1. Create Unit Background Circle (always behind the image)
                    if (!SPECIAL_INFRASTRUCTURE_UNITS.includes(unitType)) {
                        const backgroundCircle = svgElement.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        backgroundCircle.setAttribute('r', UNIT_BACKGROUND_CIRCLE_RADIUS);
                        backgroundCircle.setAttribute('cx', imageX + unitImageSize / 2);
                        backgroundCircle.setAttribute('cy', imageY + unitImageSize / 2);
                        const circleFillColor = (controllingPowerName === 'Neutral')
                            ? powerColors['Neutral']
                            : darkenColor(powerColors[controllingPowerName], 0.4);
                        backgroundCircle.setAttribute('fill', circleFillColor || 'gray');
                        backgroundCircle.setAttribute('stroke', 'white');
                        backgroundCircle.setAttribute('stroke-width', '0.5');
                        backgroundCircle.classList.add('unit-background-circle');
                        unitGroupElement.appendChild(backgroundCircle);
                    }

                    // 2. Create Unit Image
                    const unitImageElement = svgElement.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'image');
                    unitImageElement.setAttribute('href', imageFileName);
                    unitImageElement.setAttribute('width', unitImageSize);
                    unitImageElement.setAttribute('height', unitImageSize);
                    unitImageElement.setAttribute('x', imageX);
                    unitImageElement.setAttribute('y', imageY);
                    unitImageElement.classList.add('unit-token');

                    if (!SPECIAL_INFRASTRUCTURE_UNITS.includes(unitType)) {
                        if (filterId) {
                            unitImageElement.setAttribute('filter', filterId);
                        } else {
                            unitImageElement.removeAttribute('filter');
                        }
                    } else {
                        unitImageElement.removeAttribute('filter'); // Always black for infrastructure
                    }

                    unitGroupElement.appendChild(unitImageElement);

                    // 3. Create Unit Type Initial on Top Edge (ONLY FOR SEA UNITS and new infrastructure units)
                    if (SEA_UNIT_TYPES.includes(unitType) || SPECIAL_INFRASTRUCTURE_UNITS.includes(unitType)) {
                        const unitTypeTextElement = svgElement.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'text');
                        let textContent = '';
                        let textYOffset = 0; // Offset for text positioning

                        switch (unitType) {
                            case 'Major Industrial Complex':
                                textContent = 'MAJOR';
                                textYOffset = unitImageSize / 2 + SPECIAL_UNIT_TEXT_FONT_SIZE * 0.7; // Position below image
                                break;
                            case 'Minor Industrial Complex':
                                textContent = 'MINOR';
                                textYOffset = unitImageSize / 2 + SPECIAL_UNIT_TEXT_FONT_SIZE * 0.7; // Position below image
                                break;
                            case 'Air Base':
                                textContent = 'AIR';
                                textYOffset = unitImageSize / 2 + SPECIAL_UNIT_TEXT_FONT_SIZE * 0.7; // Position below image
                                break;
                            case 'Naval Base':
                                textContent = 'SEA';
                                textYOffset = unitImageSize / 2 + SPECIAL_UNIT_TEXT_FONT_SIZE * 0.7; // Position below image
                                break;
                            default: // For sea units
                                textContent = unitType.charAt(0);
                                textYOffset = unitImageSize / 2; // Vertically center within image
                                break;
                        }

                        unitTypeTextElement.textContent = textContent;
                        unitTypeTextElement.setAttribute('x', imageX + unitImageSize / 2); // Center horizontally on the image
                        unitTypeTextElement.setAttribute('y', imageY + textYOffset);
                        unitTypeTextElement.setAttribute('text-anchor', 'middle');
                        unitTypeTextElement.setAttribute('dominant-baseline', 'middle');
                        unitTypeTextElement.setAttribute('font-size', SPECIAL_UNIT_TEXT_FONT_SIZE);
                        unitTypeTextElement.setAttribute('fill', 'white');
                        unitTypeTextElement.setAttribute('stroke', 'black');
                        unitTypeTextElement.setAttribute('stroke-width', '0.2');
                        unitTypeTextElement.setAttribute('font-weight', 'bold');
                        unitTypeTextElement.classList.add('unit-type-initial');
                        unitGroupElement.appendChild(unitTypeTextElement);
                    }

                    // 4. Create Unit Count (if initialCount > 1)
                    if (initialCount > 1 && !SPECIAL_INFRASTRUCTURE_UNITS.includes(unitType)) {
                        // Position count circle right at the bottom of the background circle
                        const countCircleCx = imageX + unitImageSize / 2;
                        const backgroundCircleCenterY = imageY + unitImageSize / 2;
                        const countCircleCy = backgroundCircleCenterY + UNIT_BACKGROUND_CIRCLE_RADIUS; // Position it just below the background circle

                        const countCircle = svgElement.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        countCircle.setAttribute('cx', countCircleCx);
                        countCircle.setAttribute('cy', countCircleCy);
                        countCircle.setAttribute('r', UNIT_COUNT_CIRCLE_RADIUS);
                        countCircle.setAttribute('fill', '#FFEB3B'); // Light yellow
                        countCircle.setAttribute('stroke', 'white');
                        countCircle.setAttribute('stroke-width', '0.5');
                        countCircle.classList.add('unit-count-circle');
                        unitGroupElement.appendChild(countCircle);

                        const countText = svgElement.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'text');
                        countText.textContent = initialCount;
                        countText.setAttribute('x', countCircleCx);
                        countText.setAttribute('y', countCircleCy);
                        countText.setAttribute('text-anchor', 'middle');
                        countText.setAttribute('dominant-baseline', 'middle');
                        countText.setAttribute('font-size', UNIT_COUNT_TEXT_FONT_SIZE);
                        countText.setAttribute('fill', 'black'); // Black text
                        countText.setAttribute('stroke', 'none'); // No stroke for count text
                        countText.classList.add('unit-count-text');
                        unitGroupElement.appendChild(countText);
                    }
                } else {
                    console.error(`CRITICAL: Unit ${unitType} (count: ${initialCount}) for ${territory} could not be placed at all. Check territory data or available coordinates.`);
                }
            });
            addDragListenersToUnits();
        }



        /**
         * Fetches the SVG content and injects it directly into the DOM.
         * Applies styles and adds labels.
         */
        async function loadAndStyleSvg() {
            let unitCoordinatesToUse = null;

            // Always try to fetch from unit-coordinates.json
            try {
                const unitCoordsResponse = await fetch('unit-coordinates.json');
                if (unitCoordsResponse.ok) {
                    const fetchedCoords = await unitCoordsResponse.json();
                    if (Object.keys(fetchedCoords).length > 0) {
                        unitCoordinatesToUse = fetchedCoords;
                        console.log("Loaded unit positions from unit-coordinates.json");
                    } else {
                        console.log("unit-coordinates.json was empty, using setup.json for initial unit placement.");
                    }
                } else {
                    console.warn(`unit-coordinates.json not found or could not be loaded (status: ${unitCoordsResponse.status}). Using setup.json for initial unit placement.`);
                }
            } catch (error) {
                console.warn('Error fetching unit-coordinates.json:', error);
                console.log("Using setup.json for initial unit placement.");
            }

            // Fetch unit-profile.json
            const unitProfileResponse = await fetch('unit-profile.json');
            if (!unitProfileResponse.ok) {
                throw new Error(`HTTP error! status: ${unitProfileResponse.status} for unit-profile.json`);
            }
            const unitProfileData = await unitProfileResponse.json();

            try {
                // Fetch the territories-by-power.json file
                const territoriesResponse = await fetch('territories-by-power.json');
                if (!territoriesResponse.ok) {
                    throw new Error(`HTTP error! status: ${territoriesResponse.status} for territories-by-power.json`);
                }
                const territoriesData = await territoriesResponse.json();

                // Select data only for the "setup 1940" scenario
                const setup1940Data = territoriesData['setup 1940'];

                if (setup1940Data) {
                    // These are the top-level keys from the JSON file to exclude
                    const excludedKeys = new Set(['Impassable', 'Neutral']);

                    // Iterate over each country/power in the 1940 setup
                    for (const country in setup1940Data) {
                        // If the country is not in the exclusion list, add it to our new variable
                        if (!excludedKeys.has(country)) {
                            territoriesByCountry[country] = setup1940Data[country].territories;
                        }
                    }

                    // You can log to the console to verify the result
                    console.log("Processed Territories by Country (1940 setup):", territoriesByCountry);

                } else {
                    console.error("'setup 1940' not found in territories-by-power.json");
                }
            } catch (error) {
                console.error("Error processing territories-by-power.json:", error);
            }

            try {
                // Fetch labels.json
                const labelsResponse = await fetch('labels.json');
                if (!labelsResponse.ok) {
                    throw new Error(`HTTP error! status: ${labelsResponse.status} for labels.json`);
                }
                const loadedLabels = await labelsResponse.json();
                Object.assign(textSettings, loadedLabels); // Populate textSettings from labels.json

                // Fetch setup.json
                const setupResponse = await fetch('setup.json');
                if (!setupResponse.ok) {
                    throw new Error(`HTTP error! status: ${setup.status} for setup.json`);
                }
                const setupData = await setupResponse.json();
                window.setupData = setupData; // Make setup data globally accessible to helper functions

                const neutralResponse = await fetch('neutral.json');
                if (!neutralResponse.ok) {
                    throw new Error(`HTTP error! status: ${neutralResponse.status} for neutral.json`);
                }
                const neutralData = await neutralResponse.json();

                const neutralPowerObject = {
                    name: "Neutral",
                    territories: Object.keys(neutralData).map(territoryName => ({
                        name: territoryName,
                        units: neutralData[territoryName]
                    }))
                };
                setupData.push(neutralPowerObject);

                // to fetch other-setup.json
                const otherSetupResponse = await fetch('other-setup.json');
                if (!otherSetupResponse.ok) {
                    throw new Error(`HTTP error! status: ${otherSetupResponse.status} for other-setup.json`);
                }
                const otherSetupData = await otherSetupResponse.json();

                const seazoneLabelsResponse = await fetch('seazone-labels.json');
                if (!seazoneLabelsResponse.ok) {
                    throw new Error(`HTTP error! status: ${seazoneLabelsResponse.status} for seazone-labels.json`);
                }
                const seazoneLabelsData = await seazoneLabelsResponse.json();

                // Fetch territory-adjacencies.json
                const adjacenciesResponse = await fetch('territory-adjacencies.json');
                if (!adjacenciesResponse.ok) {
                    throw new Error(`HTTP error! status: ${adjacenciesResponse.status} for territory-adjacencies.json`);
                }
                territoryAdjacencies = await adjacenciesResponse.json(); // Assign to global variable

                // Identify small islands: a territory whose only adjacent spaces are sea zones (numbers)
                smallIslandsMap = new Set(); // Reset global variable
                for (const territoryName in territoryAdjacencies) {
                    if (isNaN(Number(territoryName))) { // Check if it's a land territory
                        const adjacencies = territoryAdjacencies[territoryName].adjacent_to || [];
                        if (adjacencies.length > 0) {
                            let allAdjacenciesAreSeaZones = true;
                            for (const adj of adjacencies) {
                                if (isNaN(Number(adj))) { // If any adjacency is not a number (i.e., another land territory)
                                    allAdjacenciesAreSeaZones = false;
                                    break;
                                }
                            }
                            if (allAdjacenciesAreSeaZones) {
                                smallIslandsMap.add(territoryName);
                            }
                        }
                    }
                }
                console.log("Small Islands identified:", [...smallIslandsMap]);


                // Fetch map.svg
                const svgResponse = await fetch('map.svg');
                if (!svgResponse.ok) {
                    throw new Error(`HTTP error! status: ${svgResponse.status} for map.svg`);
                }
                const svgText = await svgResponse.text();

                const parser = new DOMParser();
                const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');
                const newSvgElement = svgDoc.documentElement;

                // Set initial class and dimensions
                newSvgElement.classList.add('svg-content');

                // NEW: Ensure the main SVG allows filter effects to extend visually
                newSvgElement.style.overflow = 'visible';

                // Clear previous SVG content and append the new one
                svgWrapper.innerHTML = '';
                svgWrapper.appendChild(newSvgElement);
                currentSvgElement = newSvgElement; // Update the global reference

                // Create dedicated <g> elements for layering to control render order
                const backgroundLabelsGroup = newSvgElement.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'g');
                backgroundLabelsGroup.setAttribute('id', 'background-labels-layer');

                const unitLayerGroup = newSvgElement.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'g');
                unitLayerGroup.setAttribute('id', 'unit-layer');

                currentSvgElement.addEventListener('click', (event) => {
                    if (!event.ctrlKey) return;

                    const svgPoint = getSvgCoordinates(event.clientX, event.clientY);
                    const coordString = `{ "x": ${svgPoint.x.toFixed(2)}, "y": ${svgPoint.y.toFixed(2)} }`;

                    navigator.clipboard.writeText(coordString)
                        .then(() => {
                            console.log("Copied to clipboard:", coordString);
                        })
                        .catch(err => {
                            console.error("Clipboard write failed:", err);
                        });

                    // Prevent default click
                    event.stopPropagation();
                    event.preventDefault();
                });


                // Capture initial viewBox and aspect ratio
                const viewBox = newSvgElement.getAttribute('viewBox');
                if (viewBox) {
                    const parts = viewBox.split(' ').map(Number);
                    originalViewBox = { x: parts[0], y: parts[1], width: parts[2], height: parts[3] };
                    originalAspectRatio = originalViewBox.width / originalViewBox.height;
                } else {
                    // Fallback if viewBox is missing, use rendered dimensions
                    originalViewBox = { x: 0, y: 0, width: newSvgElement.clientWidth, height: newSvgElement.clientHeight };
                    originalAspectRatio = newSvgElement.clientWidth / newSvgElement.clientHeight;
                }

                // Extract IPC values from map.svg
                const territoryIpcs = {};
                const paths = newSvgElement.querySelectorAll('polygon[data-name], path[data-name]');
                paths.forEach(path => {
                    const name = path.getAttribute('data-name');
                    const ipcs = path.getAttribute('data-ipcs');
                    if (name) {
                        territoryIpcs[name] = ipcs;
                    }
                });

                // Inject CSS rules directly into the SVG
                const styleElement = newSvgElement.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'style');
                let cssRules = '';

                const polygons = newSvgElement.querySelectorAll('polygon[data-power], path[data-power]');
                const uniquePowers = new Set();

                polygons.forEach(polygon => {
                    const dataPower = polygon.getAttribute('data-power');
                    if (dataPower) {
                        const trimmedPower = dataPower.trim();
                        uniquePowers.add(trimmedPower);
                    }
                });

                uniquePowers.forEach(power => {
                    const color = powerColors[power];
                    if (color) {
                        cssRules += `polygon[data-power="${power}"], path[data-power="${power}"] { fill: ${color}; stroke: #000; stroke-width: 0.5; }\n`;
                    } else {
                        console.warn(`No color defined for data-power="${power}". Polygon may not be styled.`);
                    }
                });

                cssRules += `polygon, path { cursor: pointer; fill-opacity: 0.8; transition: fill 0.3s ease, fill-opacity 0.3s ease, stroke 0.3s ease, stroke-width 0.3s ease; }`;
                cssRules += `.hover-highlight { fill-opacity: 1.0 !important; stroke: #fff !important; stroke-width: 1 !important; }`;

                styleElement.textContent = cssRules;

                let defs = newSvgElement.querySelector('defs');
                if (defs) {
                    defs.appendChild(styleElement);
                } else {
                    defs = newSvgElement.ownerDocument.createElementNS('http://www.w3.org/2000/svg', 'defs');
                    newSvgElement.insertBefore(defs, newSvgElement.firstChild);
                    defs.appendChild(styleElement);
                }

                // Add event listeners for hover effects on all territory parts
                const allTerritoryPaths = newSvgElement.querySelectorAll('polygon[data-name], path[data-name]');

                allTerritoryPaths.forEach(path => {
                    path.addEventListener('mouseover', () => {
                        const territoryName = path.getAttribute('data-name');
                        if (territoryName) {
                            const sameTerritories = newSvgElement.querySelectorAll(`polygon[data-name="${territoryName}"], path[data-name="${territoryName}"]`);
                            sameTerritories.forEach(part => part.classList.add('hover-highlight'));
                        }
                    });

                    path.addEventListener('mouseout', () => {
                        const territoryName = path.getAttribute('data-name');
                        if (territoryName) {
                            const sameTerritories = newSvgElement.querySelectorAll(`polygon[data-name="${territoryName}"], path[data-name="${territoryName}"]`);
                            sameTerritories.forEach(part => part.classList.remove('hover-highlight'));
                        }
                    });
                });

                // Generate unit colorization filters using the new logic
                generateColorFilters(newSvgElement);

                // --- Function Call Order ---

                // 1. Add territory names and IPCs
                await addTerritoryLabels(newSvgElement, textSettings, territoryIpcs);

                // 2. Draw static infrastructure (railways, roads) - they will be behind labels and units
                drawInfrastructure(newSvgElement, otherSetupData);
                
                // 3. Add background labels (CONVOY, SHIPYARD) to their dedicated group
                newSvgElement.appendChild(backgroundLabelsGroup);
                drawConvoyAndShipyardLabels(backgroundLabelsGroup, seazoneLabelsData);

                // 4. Add the unit layer group to the SVG DOM
                newSvgElement.appendChild(unitLayerGroup);

                // 5. Fetch infrastructure coordinates

                let infrastructureCoords = null;

                try {
                    const infraResponse = await fetch('infrastructure-coordinates.json');
                    if (infraResponse.ok) {
                        const rawInfraCoords = await infraResponse.json();
                        infrastructureCoords = {};

                        for (const entry of rawInfraCoords) {
                            const { territory, unitType, x, y } = entry;
                            if (!infrastructureCoords[territory]) {
                                infrastructureCoords[territory] = [];
                            }
                            infrastructureCoords[territory].push({ unitType, x, y });
                        }
                        console.log("Loaded infrastructure positions from infrastructure-coordinates.json");
                    } else {
                        console.warn("Could not load infrastructure-coordinates.json");
                    }
                } catch (e) {
                    console.error("Error loading infrastructure-coordinates.json:", e);
                }

                // 6. Place units into their dedicated group
                placeUnits(
                    newSvgElement,
                    setupData,
                    textSettings,
                    smallIslandsMap,
                    territoryAdjacencies,
                    unitCoordinatesToUse,
                    infrastructureCoords,
                    unitProfileData,
                    unitLayerGroup // Pass the defined unit layer group
                );

                await drawNeutralFlags(newSvgElement);

                // Apply initial zoom after content is loaded and styled
                applyZoom();

                applyTerritoryColors("setup 1940"); 

            } catch (error) {
                console.error('Error loading or styling SVG or JSON files:', error);
                svgWrapper.innerHTML = `<p style="color:red;">Error loading map or configuration files. Please ensure 'map.svg', 'labels.json', 'setup.json', and 'territory-adjacencies.json' are in the same directory.</p>`;
            }
        }


        /**
         * Applies the current zoom level to the SVG element.
         * Adjusts SVG intrinsic dimensions for scrolling and centers the view.
         */
        function applyZoom() {
            if (!currentSvgElement || !originalViewBox) return;

            const wrapperWidth = svgWrapper.clientWidth;
            const wrapperHeight = svgWrapper.clientHeight;

            // Calculate the current center in SVG coordinates before zoom
            const svgPoint = currentSvgElement.createSVGPoint();
            svgPoint.x = svgWrapper.scrollLeft + wrapperWidth / 2;
            svgPoint.y = svgWrapper.scrollTop + wrapperHeight / 2;

            // Transform client coordinates to SVG user coordinates
            const CTM = currentSvgElement.getScreenCTM();
            if (!CTM) {
                console.warn("Could not get CTM for SVG element.");
                return;
            }
            const centerBeforeZoomSvg = svgPoint.matrixTransform(CTM.inverse());

            // Scale SVG's layout size based on its original viewBox
            const scaledWidth = originalViewBox.width * zoomLevel;
            const scaledHeight = originalViewBox.height * zoomLevel;

            // Apply the new dimensions
            currentSvgElement.setAttribute('width', scaledWidth);
            currentSvgElement.setAttribute('height', scaledHeight);

            updateIpcBarLayout();

            // After setting new dimensions, recalculate the CTM (it might change)
            // and then determine the new scroll position to keep the logical center visible.
            // Use requestAnimationFrame to ensure layout updates are processed
            requestAnimationFrame(() => {
                const newCTM = currentSvgElement.getScreenCTM();
                if (!newCTM) {
                    console.warn("Could not get new CTM after scaling.");
                    return;
                }

                // Transform the previous SVG center point to new screen coordinates
                const centerAfterZoomScreen = centerBeforeZoomSvg.matrixTransform(newCTM);

                // Calculate new scroll position to keep that screen point centered
                const newScrollX = centerAfterZoomScreen.x - wrapperWidth / 2;
                const newScrollY = centerAfterZoomScreen.y - wrapperHeight / 2;

                // Apply scroll position, clamping to valid ranges
                svgWrapper.scrollLeft = Math.max(0, Math.min(newScrollX, currentSvgElement.scrollWidth - wrapperWidth));
                svgWrapper.scrollTop = Math.max(0, Math.min(newScrollY, currentSvgElement.scrollHeight - wrapperHeight));
            });
        }


        /**
         * Handles key presses for zooming.
         * '=' key zooms in, '-' key zooms out.
         * @param {KeyboardEvent} event - The keyboard event object.
         */
        document.addEventListener('keydown', (event) => {
            if (!currentSvgElement) return; // Ensure SVG is loaded

            if (event.key === '=' || event.key === '+') { // Zoom in
                if (zoomLevel < 5.0) {
                    zoomLevel = Math.min(5.0, zoomLevel + zoomStep);
                    applyZoom();
                }
            } else if (event.key === '-') { // Zoom out
                if (zoomLevel > 0.2) {
                    zoomLevel = Math.max(0.2, zoomLevel - zoomStep);
                    applyZoom();
                }
            }
        });

        // --- Drag and Drop Functions ---

        /**
         * Converts screen coordinates to SVG coordinates.
         * @param {number} clientX - The clientX from a mouse/touch event.
         * @param {number} clientY - The clientY from a mouse/touch event.
         * @returns {SVGPoint} An SVGPoint object with x and y in SVG user units.
         */
        function getSvgCoordinates(clientX, clientY) {
            const svgMatrix = currentSvgElement.getScreenCTM();
            const point = currentSvgElement.createSVGPoint();
            point.x = clientX;
            point.y = clientY;
            return point.matrixTransform(svgMatrix.inverse());
        }


        /**
         * Starts the drag operation for a unit.
         * @param {Event} event - The mouse or touch event.
         */
        function startDrag(event) {
            console.log("%c--- Unit Clicked ---", "color: yellow; font-weight: bold; background-color: black; padding: 2px 5px;");
            const clickedUnit = event.currentTarget;
            const unitData = {
                "ID": clickedUnit.getAttribute('id'),
                "Unit Type": clickedUnit.getAttribute('data-unit-type'),
                "Power": clickedUnit.getAttribute('data-power'),
                "Count": clickedUnit.getAttribute('data-count'),
                "Original Territory": clickedUnit.getAttribute('data-original-territory'),
                "Currently Placed In": clickedUnit.getAttribute('data-placed-in'),
                "Has Moved": clickedUnit.getAttribute('data-has-moved'),
                "Movement Remaining": clickedUnit.getAttribute('data-movement-remaining')
            };
            console.table(unitData);

            if (event.button === 2) return; // Ignore right-click

            isDragging = true;
            currentDraggedUnit = event.currentTarget; // The 'g' element

            // --- MOVEMENT BONUS LOGIC ---
            // This bonus is applied only once at the start of a unit's first move.
            const hasMoved = currentDraggedUnit.getAttribute('data-has-moved') === 'true';
            if (!hasMoved) {
                let movementBonus = 0;
                const unitType = currentDraggedUnit.getAttribute('data-unit-type');
                const originalTerritoryName = currentDraggedUnit.getAttribute('data-original-territory');

                // Check for air unit bonus
                if (airUnitTypes.includes(unitType)) {
                    if (has1940AirBase(originalTerritoryName)) {
                        movementBonus = 1;
                    }
                // Check for sea unit bonus
                } else if (SEA_UNIT_TYPES.includes(unitType)) {
                    const adjacencies = territoryAdjacencies[originalTerritoryName]?.adjacent_to || [];
                    for (const adjacentTerritory of adjacencies) {
                        // Check if the adjacent area is a land territory (not a sea zone number)
                        if (isNaN(Number(adjacentTerritory))) {
                            if (has1940NavalBase(adjacentTerritory)) {
                                movementBonus = 1;
                                break; // Found a naval base, no need to check other adjacent territories
                            }
                        }
                    }
                }

                if (movementBonus > 0) {
                    const currentMovement = parseInt(currentDraggedUnit.getAttribute('data-movement-remaining'));
                    const newMovement = currentMovement + movementBonus;
                    currentDraggedUnit.setAttribute('data-movement-remaining', newMovement);
                    console.log(`%c+1 Movement Bonus Applied to ${unitType} in ${originalTerritoryName}. New Movement: ${newMovement}`, 'color: lightblue; font-weight: bold;');
                }
            }
            // --- END MOVEMENT BONUS LOGIC ---

            currentDraggedUnit.style.cursor = 'grabbing';
            currentDraggedUnit.parentNode.appendChild(currentDraggedUnit); // Bring to front

            const transform = currentDraggedUnit.transform.baseVal.getItem(0);
            startDragX = transform ? transform.matrix.e : 0; // Store initial X
            startDragY = transform ? transform.matrix.f : 0; // Store initial Y
            initialPlacedInTerritory = currentDraggedUnit.getAttribute('data-original-territory');

            const clientX = event.type.startsWith('touch') ? event.touches[0].clientX : event.clientX;
            const clientY = event.type.startsWith('touch') ? event.touches[0].clientY : event.clientY;

            const svgPoint = getSvgCoordinates(clientX, clientY);
            dragOffsetX = svgPoint.x - startDragX;
            dragOffsetY = svgPoint.y - startDragY;

            // (The rest of the function remains the same...)
            const unitType = currentDraggedUnit.getAttribute('data-unit-type');
            isSpecialUnitDragging = SPECIAL_INFRASTRUCTURE_UNITS.includes(unitType);

            if (isSpecialUnitDragging) {
                const territory = currentDraggedUnit.getAttribute('data-original-territory');
                const paths = currentSvgElement.querySelectorAll(`polygon[data-name="${territory}"], path[data-name="${territory}"]`);
                paths.forEach(path => path.classList.add('highlighted-territory'));
            }

            if (!isSpecialUnitDragging) {
                const paths = currentSvgElement.querySelectorAll(`polygon[data-name="${initialPlacedInTerritory}"], path[data-name="${initialPlacedInTerritory}"]`);
                paths.forEach(path => path.classList.add('highlighted-territory'));
            }

            validDropZones = [];
            const originalTerritoryName = currentDraggedUnit.getAttribute('data-original-territory');
            
            if (!isSpecialUnitDragging) { 
                const originalTerritoryPath = currentSvgElement.querySelector(`[data-name="${originalTerritoryName}"]`);
                if (originalTerritoryPath) {
                    validDropZones.push({
                        name: originalTerritoryName,
                        pathElement: originalTerritoryPath,
                        bbox: originalTerritoryPath.getBBox()
                    });
                }

                const isOriginalTerritorySmallIsland = smallIslandsMap.has(originalTerritoryName);
                const originalTerritoryAdjacencies = territoryAdjacencies[originalTerritoryName]?.adjacent_to || [];
                const hasCoastalBorders = originalTerritoryAdjacencies.some(adj => !isNaN(Number(adj)));

                if (isOriginalTerritorySmallIsland || hasCoastalBorders) {
                    originalTerritoryAdjacencies.forEach(adjName => {
                        if (!isNaN(Number(adjName))) {
                            const seaZonePath = currentSvgElement.querySelector(`[data-name="${adjName}"]`);
                            if (seaZonePath) {
                                validDropZones.push({
                                    name: adjName,
                                    pathElement: seaZonePath,
                                    bbox: seaZonePath.getBBox()
                                });
                            }
                        }
                    });
                }
            }

            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchmove', drag, { passive: false });
            document.addEventListener('touchend', endDrag);
        }

        /**
         * Handles the drag movement of a unit.
         * @param {Event} event - The mouse or touch event.
         */
        function drag(event) {
            if (!isDragging || !currentDraggedUnit) return;

            event.preventDefault(); // Prevent scrolling on touch devices

            const clientX = event.type.startsWith('touch') ? event.touches[0].clientX : event.clientX;
            const clientY = event.type.startsWith('touch') ? event.touches[0].clientY : event.clientY;

            const svgPoint = getSvgCoordinates(clientX, clientY);

            let newX = svgPoint.x - dragOffsetX;
            let newY = svgPoint.y - dragOffsetY;

            const unitType = currentDraggedUnit.getAttribute('data-unit-type');
            const unitImageSize = getUnitSize(unitType);
            const count = parseInt(currentDraggedUnit.getAttribute('data-count'));

            let groupWidth = unitImageSize;
            let groupHeight = unitImageSize;
            if (count > 1 && !SPECIAL_INFRASTRUCTURE_UNITS.includes(unitType)) {
                groupHeight = unitImageSize + (UNIT_COUNT_CIRCLE_RADIUS * 2);
                groupWidth = Math.max(groupWidth, (UNIT_COUNT_CIRCLE_RADIUS * 2));
            } else if (SPECIAL_INFRASTRUCTURE_UNITS.includes(unitType)) {
                groupHeight = unitImageSize + SPECIAL_UNIT_TEXT_FONT_SIZE * 1.5;
            }


            const potentialUnitRect = {
                x: newX,
                y: newY,
                width: groupWidth,
                height: groupHeight
            };

            if (isSpecialUnitDragging) {
                // Special units can be dragged anywhere visually
                currentDraggedUnit.setAttribute('transform', `translate(${newX}, ${newY})`);
                const unitIndex = placedUnitsData.findIndex(u => u.element === currentDraggedUnit);
                if (unitIndex !== -1) {
                    placedUnitsData[unitIndex].x = newX;
                    placedUnitsData[unitIndex].y = newY;
                }
            } else {
                // Regular units are restricted to valid drop zones
                let isWithinAnyValidZone = false;
                for (const dropZone of validDropZones) {
                    if (isRectInPath(dropZone.pathElement, potentialUnitRect)) {
                        isWithinAnyValidZone = true;
                        break;
                    }
                }

                if (isWithinAnyValidZone) {
                    currentDraggedUnit.setAttribute('transform', `translate(${newX}, ${newY})`);
                    const unitIndex = placedUnitsData.findIndex(u => u.element === currentDraggedUnit);
                    if (unitIndex !== -1) {
                        placedUnitsData[unitIndex].x = newX;
                        placedUnitsData[unitIndex].y = newY;
                    }
                }
                // If not within any valid zone, the transform is not updated,
                // effectively "sticking" the unit at the boundary of the last valid position.
            }
        }

        /**
         * Ends the drag operation.
         * @param {Event} event - The mouse or touch event.
         */
        function endDrag(event) {
            isDragging = false;
            if (isSpecialUnitDragging && currentDraggedUnit) {
                const territory = currentDraggedUnit.getAttribute('data-original-territory');
                const paths = currentSvgElement.querySelectorAll(`polygon[data-name="${territory}"], path[data-name="${territory}"]`);
                paths.forEach(path => path.classList.remove('highlighted-territory'));
            }

            if (currentDraggedUnit) {
                currentDraggedUnit.style.cursor = 'grab';

                const unitType = currentDraggedUnit.getAttribute('data-unit-type');
                const unitImageSize = getUnitSize(unitType);
                const count = parseInt(currentDraggedUnit.getAttribute('data-count'));

                let groupWidth = unitImageSize;
                let groupHeight = unitImageSize;
                if (count > 1 && !SPECIAL_INFRASTRUCTURE_UNITS.includes(unitType)) {
                    groupHeight = unitImageSize + (UNIT_COUNT_CIRCLE_RADIUS * 2);
                    groupWidth = Math.max(groupWidth, (UNIT_COUNT_CIRCLE_RADIUS * 2));
                } else if (SPECIAL_INFRASTRUCTURE_UNITS.includes(unitType)) {
                    groupHeight = unitImageSize + SPECIAL_UNIT_TEXT_FONT_SIZE * 1.5;
                }

                const transform = currentDraggedUnit.transform.baseVal.getItem(0);
                const currentX = transform ? transform.matrix.e : 0;
                const currentY = transform ? transform.matrix.f : 0;

                // Update the x/y in placedUnitsData
                const indexToUpdate = placedUnitsData.findIndex(entry => entry.element === currentDraggedUnit);
                if (indexToUpdate !== -1) {
                    placedUnitsData[indexToUpdate].x = currentX;
                    placedUnitsData[indexToUpdate].y = currentY;
                }

                const unitRect = {
                    x: currentX,
                    y: currentY,
                    width: groupWidth,
                    height: groupHeight
                };

                let finalX = currentX; // Default to current visual position
                let finalY = currentY; // Default to current visual position
                let finalPlacedInTerritory = initialPlacedInTerritory; // Default to original territory

                if (isSpecialUnitDragging) {
                    // For special units, visual position is final, but logical territory is original
                    finalPlacedInTerritory = initialPlacedInTerritory;
                } else {
                    // For regular units, check drop zones and potentially snap back
                    let foundValidDropZone = false;
                    let droppedInSeaZone = false;
                    let actualDroppedZoneName = null;

                    for (const dropZone of validDropZones) {
                        if (isRectInPath(dropZone.pathElement, unitRect)) {
                            foundValidDropZone = true;
                            actualDroppedZoneName = dropZone.name;

                            if (!isNaN(Number(dropZone.name))) {
                                droppedInSeaZone = true;
                            }
                            break;
                        }
                    }

                    if (foundValidDropZone) {
                        if (droppedInSeaZone) {
                            finalPlacedInTerritory = currentDraggedUnit.getAttribute('data-original-territory');
                        } else {
                            finalPlacedInTerritory = actualDroppedZoneName;
                        }
                    } else {
                        console.warn(`Unit dropped outside valid zones. Snapping back to ${initialPlacedInTerritory}.`);
                        finalX = startDragX;
                        finalY = startDragY;
                        finalPlacedInTerritory = initialPlacedInTerritory;
                    }
                }

                currentDraggedUnit.setAttribute('transform', `translate(${finalX}, ${finalY})`);
                currentDraggedUnit.setAttribute('data-placed-in', finalPlacedInTerritory);

                // Update the placedUnitsData array with the final territory and position
                const unitIndex = placedUnitsData.findIndex(u => u.element === currentDraggedUnit);
                if (unitIndex !== -1) {
                    placedUnitsData[unitIndex].placedIn = finalPlacedInTerritory;
                    placedUnitsData[unitIndex].x = finalX;
                    placedUnitsData[unitIndex].y = finalY;
                }

                // Remove highlight from the original territory (only if it was highlighted)
                if (!isSpecialUnitDragging) {
                    const originalTerritoryPaths = currentSvgElement.querySelectorAll(`polygon[data-name="${initialPlacedInTerritory}"], path[data-name="${initialPlacedInTerritory}"]`);
                    originalTerritoryPaths.forEach(path => path.classList.remove('highlighted-territory'));
                }
                
                currentDraggedUnit = null;
                isSpecialUnitDragging = false; // Reset the flag
                validDropZones = []; // Clear valid drop zones for next drag
                initialPlacedInTerritory = null; // Reset for next drag
                startDragX = 0; // Reset
                startDragY = 0; // Reset
            }
            document.removeEventListener('mousemove', drag);
            document.removeEventListener('mouseup', endDrag);
            document.removeEventListener('touchmove', drag);
            document.removeEventListener('touchend', endDrag);
        }

        /**
         * Adds drag listeners to all unit groups.
         */
        function addDragListenersToUnits() {
            const unitGroups = svgWrapper.querySelectorAll('.unit-stack-group');
            unitGroups.forEach(group => {
                group.removeEventListener('mousedown', startDrag); // Prevent duplicate listeners
                group.removeEventListener('touchstart', startDrag);

                group.addEventListener('mousedown', startDrag);
                group.addEventListener('touchstart', startDrag, { passive: false });
            });
        }


        loadAndStyleSvg('map.svg').then(() => {
            console.log("SVG loaded and styled. Calculating and displaying IPCs...");
            calculateAndDisplayIPCs("setup 1940");
            drawOtherLabels(); // <-- ADD THIS LINE
            // The call to positionRdBar(); can remain if you need it.
        }).catch(error => {
            console.error("Error during map loading or IPC calculation:", error);
        });


        // Re-apply zoom on resize to adjust wrapper dimensions
        window.addEventListener('resize', applyZoom);

        /**
         * Fetches IPC values from map.svg (data-ipcs attributes)
         * and normalizes territory names (replaces spaces with underscores).
         * @param {SVGElement} svgElement - The current SVG DOM element.
         * @returns {Object} An object mapping normalized territory names to their IPC values.
         */
        function getTerritoryIpcsFromSvg(svgElement) {
            const territoryIpcs = {};
            const pathElements = svgElement.querySelectorAll('[data-name][data-ipcs]');
            pathElements.forEach(pathEl => {
                let territoryName = pathEl.getAttribute('data-name');
                territoryName = territoryName.replace(/ /g, '_'); // Replace all spaces with underscores

                const ipcs = pathEl.getAttribute('data-ipcs');
                territoryIpcs[territoryName] = parseInt(ipcs, 10) || 0;
            });
            console.log("Normalized Territories from SVG:", territoryIpcs); // For debugging
            return territoryIpcs;
        }

        /**
         * Calculates and displays total IPCs for each power, and creates the 1-70 squares.
         * @param {string} setupName - The setup name (e.g., "setup 1940").
         */
        async function calculateAndDisplayIPCs(setupName = "setup 1940") {
            try {
                // 1. Fetch territories by power
                const territoriesResponse = await fetch('territories-by-power.json');
                if (!territoriesResponse.ok) {
                    throw new Error(`HTTP error! status: ${territoriesResponse.status} for territories-by-power.json`);
                }
                const territoriesData = await territoriesResponse.json();
                const currentSetupTerritories = territoriesData[setupName];

                if (!currentSetupTerritories) {
                    console.warn(`Setup '${setupName}' not found in territories-by-power.json.`);
                    return;
                }

                // 2. Get IPC values from the loaded SVG (already normalized within the function)
                if (!currentSvgElement) {
                    console.error("SVG element not loaded yet. Cannot get IPCs.");
                    return;
                }
                const territoryIpcs = getTerritoryIpcsFromSvg(currentSvgElement);

                // 3. Calculate total IPCs for each playable power
                const totalIpcsByPower = {};
                // Define the exact list of powers to be included in the IPC calculation
                const playablePowers = ['China', 'Commonwealth', 'France', 'Germany', 'Italy', 'Japan', 'UK', 'US', 'USSR'];

                for (const powerName of playablePowers) {
                    // Ensure this power exists in the data before processing
                    if (!currentSetupTerritories[powerName]) {
                        continue;
                    }

                    const territoriesOwned = currentSetupTerritories[powerName].territories;
                    let totalIpcs = 0;
                    territoriesOwned.forEach(territory => {
                        // Normalize the territory name from JSON: replace spaces with underscores
                        const normalizedTerritory = territory.replace(/ /g, '_');

                        if (territoryIpcs[normalizedTerritory] !== undefined) {
                            totalIpcs += territoryIpcs[normalizedTerritory];
                        } else {
                            // console.warn(`IPC value not found for territory (after normalization): "${territory}" (normalized to "${normalizedTerritory}") for power ${powerName}`);
                        }
                    });
                    totalIpcsByPower[powerName] = totalIpcs;
                }

                console.log("Calculated Total IPCs (excluding Neutral/Impassable):", totalIpcsByPower);

                // 4. Prepare data for display: map IPC value to list of powers
                const powersByIpcValue = {};
                for (const powerName in totalIpcsByPower) {
                    const ipcValue = totalIpcsByPower[powerName];
                    if (!powersByIpcValue[ipcValue]) {
                        powersByIpcValue[ipcValue] = [];
                    }
                    powersByIpcValue[ipcValue].push(powerName);
                }

                // 5. Display the results in 1-70 squares
                const ipcDisplayBar = document.getElementById('ipcDisplayBar');
                ipcDisplayBar.innerHTML = ''; // Clear previous content

                for (let i = 1; i <= 70; i++) {
                    const square = document.createElement('div');
                    square.classList.add('ipc-square');

                    // Create the flags container
                    const flagsContainer = document.createElement('div');
                    flagsContainer.classList.add('ipc-flags-container');

                    if (powersByIpcValue[i]) {
                        const powersForThisIpc = powersByIpcValue[i];

                        if (powersForThisIpc.length === 2) {
                            flagsContainer.classList.add('vertical-split');
                            powersForThisIpc.forEach(powerName => {
                                const flagItem = document.createElement('div');
                                flagItem.classList.add('flag-item');
                                const flagImg = document.createElement('img');
                                flagImg.src = `${powerName}.png`; // Adjust path as needed
                                flagImg.alt = `${powerName} Flag`;
                                flagImg.classList.add('flag-icon');
                                flagItem.appendChild(flagImg);
                                flagsContainer.appendChild(flagItem);
                            });
                        } else if (powersForThisIpc.length === 3) {
                            flagsContainer.classList.add('horizontal-split');
                             // To show "the center of the three flags", we'll just display them side-by-side
                             // and rely on object-fit:cover and flexbox to handle the scaling/cropping.
                            powersForThisIpc.forEach(powerName => {
                                const flagItem = document.createElement('div');
                                flagItem.classList.add('flag-item');
                                const flagImg = document.createElement('img');
                                flagImg.src = `${powerName}.png`; // Adjust path as needed
                                flagImg.alt = `${powerName} Flag`;
                                flagImg.classList.add('flag-icon');
                                flagItem.appendChild(flagImg);
                                flagsContainer.appendChild(flagItem);
                            });
                        } else { // For 1 power or more than 3
                            powersForThisIpc.forEach(powerName => {
                                const flagItem = document.createElement('div');
                                flagItem.classList.add('flag-item');
                                const flagImg = document.createElement('img');
                                flagImg.src = `flags/${powerName}.png`;
                                flagImg.alt = `${powerName} Flag`;
                                flagImg.classList.add('flag-icon');
                                flagItem.appendChild(flagImg);
                                flagsContainer.appendChild(flagItem);
                            });
                        }
                    }
                    
                    square.appendChild(flagsContainer); // Add the container to the square

                    const ipcNumberSpan = document.createElement('span');
                    ipcNumberSpan.classList.add('ipc-number');
                    ipcNumberSpan.textContent = i;
                    square.appendChild(ipcNumberSpan); // Add the number on top

                    ipcDisplayBar.appendChild(square);
                }

                // Call the positioning function after content is added
                updateIpcBarLayout();

            } catch (error) {
                console.error('Error calculating or displaying IPCs:', error);
                const ipcDisplayBar = document.getElementById('ipcDisplayBar');
                ipcDisplayBar.innerHTML = '<div style="color: red; padding: 10px;">Error loading IPC data. Check console for details.</div>';
            }
        }

        /**
     * Updates the width of the IPC bar and its squares to match the SVG map's width.
     */
        function updateIpcBarLayout() {
            if (!currentSvgElement) return;

            const ipcDisplayBar = document.getElementById('ipcDisplayBar');
            const mapWidth = currentSvgElement.getAttribute('width');

            if (mapWidth && ipcDisplayBar) {
                // Set the entire bar's width to match the map
                ipcDisplayBar.style.width = `${mapWidth}px`;

                const squares = ipcDisplayBar.querySelectorAll('.ipc-square');
                if (squares.length > 0) {
                    // Calculate the width for each individual square
                    const squareWidth = parseFloat(mapWidth) / squares.length;
                    squares.forEach(square => {
                        square.style.width = `${squareWidth}px`;
                        // Optional: Make squares perfectly square
                        square.style.height = `${squareWidth}px`; 
                    });
                }
            }
        }
    /* ============================================= */
    /* == SCRIPT FOR SIDE TABS AND DRAGGABLE PANELS == */
    /* ============================================= */

    document.addEventListener('DOMContentLoaded', () => {
        const tabs = document.querySelectorAll('.side-tab');
        const panels = document.querySelectorAll('.draggable-panel');
        const closeButtons = document.querySelectorAll('.close-panel');

        // Function to show a specific panel
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const targetId = tab.getAttribute('data-target');
                const targetPanel = document.getElementById(targetId);

                if (targetPanel) {
                    const isVisible = targetPanel.classList.contains('visible');

                    // If the panel was not already visible, show it.
                    // This prevents a panel from hiding itself if its tab is clicked again.
                    if (!isVisible) {
                        targetPanel.classList.add('visible');

                        // Dynamically adjust position after making it visible
                        const panelRect = targetPanel.getBoundingClientRect();
                        const viewportHeight = window.innerHeight;
                        // Get height of sticky top bar, default to 40px if not found or no offsetHeight
                        const topBarElement = document.getElementById('stickyTopBar');
                        const topBarHeight = topBarElement ? topBarElement.offsetHeight : 40;
                        const minTopPadding = 20; // Minimum padding from the top of the viewport
                        const bottomPadding = 20; // Padding from the bottom of the viewport

                        let calculatedTop = topBarHeight + minTopPadding; // Default top position below the sticky bar

                        // Check if the panel's calculated bottom edge goes beyond the viewport
                        if ((panelRect.height + calculatedTop + bottomPadding) > viewportHeight) {
                            // If it does, adjust the top position to bring the bottom edge within bounds
                            calculatedTop = viewportHeight - panelRect.height - bottomPadding;
                        }
                        
                        // Ensure the panel is not placed higher than the minimum allowed top position
                        // (i.e., below the sticky top bar and its padding)
                        calculatedTop = Math.max(topBarHeight + minTopPadding, calculatedTop);

                        targetPanel.style.top = `${calculatedTop}px`;
                        targetPanel.style.right = `${minTopPadding}px`; // Ensure it stays aligned to the right
                        targetPanel.style.left = 'unset'; // Remove left positioning if it was there
                    }
                }
            });
        });

        // Function to close panels
        closeButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent the header's drag from starting
                const panel = button.closest('.draggable-panel');
                if (panel) {
                    panel.classList.remove('visible');
                }
            });
        });

        // Function to make panels draggable
        panels.forEach(panel => {
            const header = panel.querySelector('.panel-header');
            if (!header) return;

            let isDragging = false;
            let offsetX, offsetY;

            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                // Calculate offset from the top-left of the panel
                offsetX = e.clientX - panel.offsetLeft;
                offsetY = e.clientY - panel.offsetTop;
                
                panel.style.cursor = 'grabbing';
                // Setting position to absolute is necessary for top/left to work correctly
                panel.style.position = 'absolute';
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                // Calculate new position
                let newX = e.clientX - offsetX;
                let newY = e.clientY - offsetY;
                
                // Boundary checks to keep panel within viewport
                newX = Math.max(0, Math.min(newX, window.innerWidth - panel.offsetWidth));
                newY = Math.max(0, Math.min(newY, window.innerHeight - panel.offsetHeight));

                panel.style.left = `${newX}px`;
                panel.style.top = `${newY}px`;
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
                panel.style.cursor = 'default';
            });
        });
    });
    </script>
</body>
</html>